<!DOCTYPE html>
<html style="font-size: 16px;" lang="en"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <meta name="keywords" content="">
    <meta name="description" content="">
    <title>Nickelium in USDT</title>
    <link rel="stylesheet" href="nicepage.css" media="screen">
<link rel="stylesheet" href="Nickelium-in-USDT.css" media="screen">
    <script class="u-script" type="text/javascript" src="jquery.js" defer=""></script>
    <script class="u-script" type="text/javascript" src="nicepage.js" defer=""></script>
    <meta name="generator" content="Nicepage 7.14.0, nicepage.com">
    
    
    
    
    
    
    
    
    
    
    
    <link id="u-page-google-font" rel="stylesheet" href="https://fonts.googleapis.com/css2?display=swap&amp;family=Roboto:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&amp;family=Open+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;1,300;1,400;1,500;1,600;1,700;1,800">
    <script type="application/ld+json">{
		"@context": "http://schema.org",
		"@type": "Organization",
		"name": "Site Main Ethereum",
		"logo": "images/logo-nickelium.svg"
}</script>
    <meta name="theme-color" content="#478ac9">
    <meta property="og:title" content="Nickelium in USDT">
    <meta property="og:description" content="">
    <meta property="og:type" content="website">
  <meta name="robots" content="noindex, nofollow"><meta name="robots" content="noindex, nofollow"><meta data-intl-tel-input-cdn-path="intlTelInput/"></head>
  <body data-path-to-root="./" data-include-products="false" class="u-body u-clearfix u-custom-color-4 u-xl-mode" data-lang="en"><header class="u-clearfix u-custom-color-4 u-header" id="sec-6bd7" data-animation-name="" data-animation-duration="0" data-animation-delay="0" data-animation-direction=""><div class="u-clearfix u-sheet u-sheet-1">
        <a href="./" data-page-id="132619714" class="u-image u-logo u-image-1" data-image-width="150" data-image-height="47" title="Home">
          <img src="images/logo-nickelium.svg" class="u-logo-image u-logo-image-1" title="Home">
        </a>
        <nav class="u-dropdown-icon u-menu u-menu-dropdown u-offcanvas u-menu-1" role="navigation" aria-label="Menu navigation">
          <div class="menu-collapse u-custom-font u-font-roboto" style="font-size: 1rem; letter-spacing: 0px;">
            <a class="u-button-style u-custom-color u-custom-left-right-menu-spacing u-custom-padding-bottom u-custom-top-bottom-menu-spacing u-hamburger-link u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base u-hamburger-link-1" href="#" tabindex="-1" aria-label="Open menu" aria-controls="f706">
              <svg class="u-svg-link" viewBox="0 0 24 24"><use xlink:href="#menu-hamburger"></use></svg>
              <svg class="u-svg-content" version="1.1" id="menu-hamburger" viewBox="0 0 16 16" x="0px" y="0px" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg"><g><rect y="1" width="16" height="2"></rect><rect y="7" width="16" height="2"></rect><rect y="13" width="16" height="2"></rect>
</g></svg>
            </a>
          </div>
          <div class="u-custom-menu u-nav-container">
            <ul class="u-custom-font u-font-roboto u-nav u-unstyled u-nav-1" role="menubar"><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="./" style="padding: 10px 20px;">Home</a>
</li><li role="none" class="u-nav-item"><a tabindex="-1" role="menuitem" class="u-button-style u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" aria-haspopup="true" aria-current="page" style="padding: 10px 20px;">Menu</a><div class="u-nav-popup"><ul role="menu" class="u-custom-font u-font-roboto u-h-spacing-20 u-nav u-unstyled u-v-spacing-10 u-nav-2" aria-label="Menu menu"><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-custom-color-4 u-nav-link" href="Nickelium-in-Ether.html">Nickelium in Ether</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-custom-color-4 u-nav-link" href="Nickelium-in-USDT.html">Nickelium in USDT</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-custom-color-4 u-nav-link" href="Nickelium-in-USDC.html">Nickelium in USDC</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-custom-color-4 u-nav-link" href="Buy-with-credit-card.html" target="_blank">Buy with credit card</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-custom-color-4 u-nav-link" href="Transfer-Nickelium.html" target="_blank">Transfer Nickelium</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-custom-color-4 u-nav-link" href="Nickelium-Transfers-History.html" target="_blank">My transfers History</a>
</li></ul>
</div>
</li></ul>
          </div>
          <div class="u-custom-menu u-nav-container-collapse" id="f706" role="region" aria-label="Menu panel">
            <div class="u-container-style u-custom-color-4 u-inner-container-layout u-opacity u-opacity-95 u-sidenav">
              <div class="u-inner-container-layout u-sidenav-overflow">
                <div class="u-menu-close" tabindex="-1" aria-label="Close menu"></div>
                <ul class="u-align-center u-nav u-popupmenu-items u-unstyled u-nav-3" role="menubar"><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="./">Home</a>
</li><li role="none" class="u-nav-item"><a tabindex="-1" role="menuitem" class="u-button-style u-nav-link" aria-haspopup="true" aria-current="page">Menu</a><div class="u-nav-popup"><ul role="menu" class="u-custom-font u-font-roboto u-h-spacing-20 u-nav u-unstyled u-v-spacing-10 u-nav-4" aria-label="Menu menu"><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="Nickelium-in-Ether.html">Nickelium in Ether</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="Nickelium-in-USDT.html">Nickelium in USDT</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="Nickelium-in-USDC.html">Nickelium in USDC</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="Buy-with-credit-card.html" target="_blank">Buy with credit card</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="Transfer-Nickelium.html" target="_blank">Transfer Nickelium</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="Nickelium-Transfers-History.html" target="_blank">My transfers History</a>
</li></ul>
</div>
</li></ul>
              </div>
            </div>
            <div class="u-menu-overlay u-opacity u-opacity-70"></div>
          </div>
        </nav>
        <div class="custom-expanded u-clearfix u-custom-html u-preserve-proportions u-custom-html-1">
          <div>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title></title>
            <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
            <style> #connectButton {
    background: linear-gradient(to bottom right, #6211f0, #8c2dda);
    color: white; /* Ensure text is visible */
    padding: 10px 20px; /* Adjust padding as needed */
    border-radius: 8px; /* Match other rounded elements */
    border: none; /* Remove any default button borders */
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center; /* Center content horizontally */
    font-size: 1.1em;
    font-weight: bold;
    transition: background-color 0.2s ease;
}

#connectButton:hover {
    background: linear-gradient(to bottom right, #8c2dda, #6211f0);
}

        /* General SweetAlert2 styling for custom buttons */
        .swal2-html-container { /* This is the div SweetAlert2 uses for 'html' content */
            max-height: 300px ;  /* Adjust as needed */
            overflow-y: auto ;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center items horizontally within the container */
        }
        .swal2-html-container button {
            display: flex; /* Make buttons flex containers for icon and text */
            align-items: center; /* Vertically align icon and text */
            justify-content: flex-start; /* Align content to the start (left) */
            margin: 8px auto; /* Add vertical margin and center horizontally */
            width: 80%; /* Make buttons take up most of the width */
            max-width: 280px; /* Max width for larger screens */
            padding: 12px 20px; /* Add padding */
            border-radius: 8px; /* Slightly rounded corners */
            font-size: 1.1em; /* Larger font size */
            font-weight: bold;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: left; /* Ensure text aligns left within the button */
        }
        .swal2-html-container button img {
            margin-right: 15px; /* Space between icon and text */
            width: 38px; /* Slightly larger icons */
            height: 38px;
        }
        /* Specific button colors */
        #btnMetamask { background-color: #f6851b; }
        #btnCoinbase { background-color: #0052FF; }
        #btnTrust { background-color: #3375BB; }
        /* REMOVED: #btnBinance { background-color: #F0B90B; } */
        /* Hover effects */
        #btnMetamask:hover { background-color: #e07a10; }
        #btnCoinbase:hover { background-color: #0042d0; }
        #btnTrust:hover { background-color: #2a63a0; }
        /* REMOVED: #btnBinance:hover { background-color: #d8a000; } */
        /* Styles for the Cancel button if you choose to include it as part of the HTML */
        .swal2-styled.swal2-cancel {
            background-color: #6c757d !important; /* Default grey for cancel */
            color: white !important;
            margin-top: 15px; /* Add more space above cancel button */
            justify-content: center !important; /* Center the text for cancel button */
        }
        .swal2-styled.swal2-cancel:hover {
            background-color: #5a6268 !important;
        } </style>
            <button id="connectButton">
              <style="width: 20px;="" height:="" margin-right:="" 10px;"=""> Connect </style="width:>
            </button>
            <div id="walletInfo"></div>
            <div id="qrCodeContainer" style="display:none; text-align: center; margin-top: 20px;">
              <h3>Scan to open this DApp in your mobile wallet:</h3>
              <div id="qrcode" style="margin-top: 20px;"></div>
              <p style="margin-top: 20px;">After scanning, please manually click "Connect Wallet" inside your mobile app's browser to connect.</p>
            </div>
            <script> // Define appUtils before any other code that might use it
    window.appUtils = {
        deepEqual: function(a, b) {
            try {
                return JSON.stringify(this.convertBigIntToString(a)) ===
                                     JSON.stringify(this.convertBigIntToString(b));
            } catch (e) {
                console.error("Comparison error:", e);
                return false;
            }
        },
        convertBigIntToString: function(obj) {
            if (typeof obj === 'bigint') return obj.toString();
            if (Array.isArray(obj)) return obj.map(this.convertBigIntToString.bind(this));
            if (obj && typeof obj === 'object') {
                return Object.fromEntries(
                    Object.entries(obj).map(([k, v]) => [k, this.convertBigIntToString(v)])
                );
            }
            return obj;
        },
        formatEth: function(wei) {
            if (!window.appState?.web3) return "0.00";
            try {
                return parseFloat(window.appState.web3.utils.fromWei(wei.toString(), 'ether'))
                    .toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 4 });
            } catch (e) {
                console.error("Format ETH error:", e);
                return "0.00";
            }
        },
        formatToken: function(amount) {
            try {
                return (Number(amount) / 1000).toLocaleString('en-US', {
                    minimumFractionDigits: 1,
                    maximumFractionDigits: 3
                });
            } catch (e) {
                console.error("Format token error:", e);
                return "0.0";
            }
        }
    };
    class WalletManager {
        static state = {
            web3: null,
            userAccount: null,
            isConnected: false,
            contractAddress: '0x5E2aDEb82C79341C20fD94aC497f57ee5Ba50725',
            isMobile: false,
            qrCodeShown: false
        };
        static init() {
            if (typeof Web3 === 'undefined' || typeof Swal === 'undefined' || typeof QRCode === 'undefined') {
                setTimeout(() => this.init(), 200); // Retry initialization
                return;
            }
            this.state.isMobile = this.detectMobile();
            if (document.readyState === 'complete') {
                this.initialize();
            } else {
                document.addEventListener('DOMContentLoaded', () => this.initialize());
            }
        }
        static initialize() {
            this.setupEventListeners();
            // Attempt to connect immediately if a wallet is present (e.g., in DApp browser)
            if (this.hasWalletInCurrentBrowser()) {
                this.checkPersistedConnection();
            } else {
                this.updateUI();
            }
            window.appState = {
                get web3() { return WalletManager.state.web3; },
                get userAccount() { return WalletManager.state.userAccount; },
                get isConnected() { return WalletManager.state.isConnected; },
                get contractAddress() { return WalletManager.state.contractAddress; }
            };
            window.addEventListener('appState:connectionChanged', (e) => {
                if (e.detail?.ready) {
                    this.handleConnectionReady();
                }
            });
        }
        static detectMobile() {
            const toMatch = [
                /Android/i, /webOS/i, /iPhone/i, /iPad/i, /iPod/i, /BlackBerry/i, /Windows Phone/i
            ];
            return toMatch.some((toMatchItem) => navigator.userAgent.match(toMatchItem));
        }
        static async checkPersistedConnection() {
            if (!this.hasWalletInCurrentBrowser()) {
                return false;
            }
            try {
                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                if (accounts.length > 0) {
                    await this.handleSuccessfulConnection(accounts[0]);
                    return true;
                } else {
                    if (localStorage.getItem('walletConnected') === 'true') {
                        return await this.connectInjectedWallet();
                    }
                }
            } catch (error) {
                console.error(`Auto-reconnect failed: ${error.message}`);
            }
            this.updateUI();
            return false;
        }
        static hasWalletInCurrentBrowser() {
            return typeof window.ethereum !== 'undefined';
        }
        static async connectInjectedWallet() {
            try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (accounts.length > 0) {
                    await this.handleSuccessfulConnection(accounts[0]);
                    return true;
                }
            } catch (error) {
                Swal.fire({
                    title: 'Connection Error',
                    text: error.message,
                    icon: 'error'
                });
            }
            return false;
        }
        static connectMobileWalletViaDeeplink(walletType = 'metamask') {
            const currentUrl = window.location.href;
            const dappUrlEncoded = encodeURIComponent(currentUrl);
            let deepLinkUrl = '';
            let walletName = '';
            let troubleshootingText = '';
            switch (walletType) {
                case 'metamask':
                    deepLinkUrl = `https://metamask.app.link/dapp/${currentUrl}`;
                    walletName = 'MetaMask';
                    troubleshootingText = 'You may need to manually navigate to this DApp URL within MetaMask\'s internal browser.';
                    break;
                case 'coinbase':
                    deepLinkUrl = `https://go.cb-w.com/dapp?cb_url=${dappUrlEncoded}`;
                    walletName = 'Coinbase Wallet';
                    troubleshootingText = `<b>IMPORTANT:</b> If the DApp page doesn't open directly (e.g., if it opens to the wallet's dashboard), please manually navigate to this URL: <br><br><code>${window.location.href}</code><br><br> within Coinbase Wallet's DApp browser.`;
                    break;
                /* REMOVED BINANCE CASE
                case 'binance':
                    deepLinkUrl = `binance://dapp?url=${dappUrlEncoded}`;
                    walletName = 'Binance Wallet';
                    troubleshootingText = 'You may need to manually navigate to this DApp URL within Binance Wallet\'s internal browser. Please verify official Binance deep link documentation if issues persist.';
                    break;
                */
                case 'kraken':
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                    deepLinkUrl = isIOS
                        ? `kraken://open?url=${dappUrlEncoded}`
                        : `kraken://dapp/${dappUrlEncoded}`;
                    walletName = 'Kraken Wallet';
                    troubleshootingText = 'After opening Kraken Wallet, you may need to manually confirm the connection.';
                    break;
                case 'trust':
                    deepLinkUrl = `https://link.trustwallet.com/open_url?url=${dappUrlEncoded}`;
                    walletName = 'Trust Wallet';
                    troubleshootingText = 'You may need to manually navigate to this DApp URL within Trust Wallet\'s internal browser.';
                    break;
                case 'rabby':
                    deepLinkUrl = `rabby://dapp?url=${dappUrlEncoded}`;
                    walletName = 'Rabby Wallet';
                    troubleshootingText = 'If Rabby doesn\'t open directly to the DApp, please navigate to this URL within Rabby\'s internal browser.';
                    break;
                
                default:
                    deepLinkUrl = `https://metamask.app.link/dapp/${currentUrl}`;
                    walletName = 'MetaMask';
                    troubleshootingText = 'You may need to manually navigate to this DApp URL within MetaMask\'s internal browser.';
            }
            // Attempt to open the deep link
            window.location.href = deepLinkUrl;
            Swal.fire({
                title: `Opening ${walletName}...`,
                html: `Please confirm to open this DApp in your ${walletName} app.
                        <br><br><b>If ${walletName} doesn't open or prompt you, please ensure it's installed and try again.</b>
                        <br>${troubleshootingText}`,
                icon: 'info',
                showConfirmButton: false,
                allowOutsideClick: false,
                allowEscapeKey: false,
                didOpen: () => {
                    Swal.showLoading();
                }
            });
        }
        static showQrCodeOption() {
            const qrCodeContainer = document.getElementById('qrCodeContainer');
            const connectButton = document.getElementById('connectButton');
            if (!this.state.qrCodeShown) {
                qrCodeContainer.style.display = 'block';
                connectButton.style.display = 'none';
                const qrData = window.location.href;
                document.getElementById("qrcode").innerHTML = '';
                new QRCode(document.getElementById("qrcode"), {
                    text: qrData,
                    width: 200,
                    height: 200
                });
                this.state.qrCodeShown = true;
            } else {
                qrCodeContainer.style.display = 'none';
                connectButton.style.display = 'block';
                document.getElementById("qrcode").innerHTML = '';
                this.state.qrCodeShown = false;
            }
            Swal.close();
        }
        static async handleSuccessfulConnection(account) {
            this.state = {
                ...this.state,
                web3: new Web3(window.ethereum),
                userAccount: account,
                isConnected: true
            };
            await new Promise(resolve => setTimeout(resolve, 300));
            localStorage.setItem('walletConnected', 'true');
            this.updateUI();
            Swal.close();
            await Swal.fire({
                position: 'top-end',
                icon: 'success',
                title: 'Wallet Connected',
                showConfirmButton: false,
                timer: 1500
            });
            window.dispatchEvent(new CustomEvent('appState:connectionChanged', {
                detail: { ready: true }
            }));
            document.getElementById('qrCodeContainer').style.display = 'none';
            this.state.qrCodeShown = false;
        }
        static handleConnectionReady() {
            // These functions are expected to be defined globally if needed
            if (window.initializeBuyOrders) {
                initializeBuyOrders();
            }
            if (window.refreshBuyOrders) {
                refreshBuyOrders();
            }
            if (window.initializeSellOrders) {
                initializeSellOrders();
            }
            if (window.refreshSellOrders) {
                refreshSellOrders();
            }
        }
        static updateUI() {
            const btn = document.getElementById('connectButton');
            const info = document.getElementById('walletInfo');
            if (btn && info) {
                if (this.state.isConnected && this.state.userAccount) {
                    btn.innerHTML = '<style="width: 20px; height: 20px; margin-right: 10px;"> Connected';
                    btn.disabled = true;
                    const shortAddress = `${this.state.userAccount.slice(0, 6)}...${this.state.userAccount.slice(-4)}`;
                    info.innerHTML = `<span style="font-family: monospace">${shortAddress}</span>`;
                    btn.style.display = 'block';
                } else {
                    btn.innerHTML = '<style="width: 20px; height: 20px; margin-right: 10px;"> Connect';
                    btn.disabled = false;
                    info.textContent = '';
                    if (!this.state.qrCodeShown) {
                        btn.style.display = 'block';
                    }
                }
            }
        }
        static showWalletError() {
            const isMobileBrowser = this.detectMobile();
            let htmlContent = `<p>Please install a compatible wallet extension or mobile app.</p>`;
            if (!isMobileBrowser) {
                htmlContent += `
                    <p>For desktop, try MetaMask or Rabby browser extensions.</p>
                    <div style="display: flex; gap: 20px; justify-content: center; margin-top: 20px;">
                        <a href="https://metamask.io/" target="_blank">
                            <img src="https://freelogopng.com/images/all_img/1683020955metamask-icon-png.png" style="width: 50px; height: 50px;">
                        </a>
                        <a href="https://rabby.io/" target="_blank">
                            <img src="https://rabby.io/images/logo.png" style="width: 50px; height: 50px;">
                        </a>
                    </div>
                `;
            } else {
                htmlContent += `
                    <p>For mobile, please install a DApp browser like MetaMask Mobile, Trust Wallet, or Coinbase Wallet.</p>
                    <div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-top: 20px;">
                        <a href="https://metamask.io/download/" target="_blank">
                            <img src="https://freelogopng.com/images/all_img/1683020955metamask-icon-png.png" style="width: 50px; height: 50px;"><br>MetaMask
                        </a>
                        <a href="https://www.coinbase.com/wallet" target="_blank">
                            <img src="https://cdn.worldvectorlogo.com/logos/coinbase-wallet-2.svg" style="width: 50px; height: 50px;"><br>Coinbase
                        </a>
                        <a href="https://trustwallet.com/download/" target="_blank">
                            <img src="https://seeklogo.com/images/T/trust-wallet-token-twt-logo-B13936F73F-seeklogo.com.png" style="width: 50px; height: 50px;"><br>Trust Wallet
                        </a>
                    </div>
                    <p style="margin-top: 15px;">After installing, you will need to open this DApp within the wallet's internal browser and then click 'Connect Wallet' on this page.</p>
                `;
            }
            Swal.fire({
                title: 'Wallet Required',
                html: htmlContent,
                confirmButtonText: 'I installed it, try again'
            }).then(() => {
                window.location.reload();
            });
        }
        static setupEventListeners() {
            const connectBtn = document.getElementById('connectButton');
            if (connectBtn) {
                connectBtn.addEventListener('click', () => {
                    if (this.state.isMobile && !this.hasWalletInCurrentBrowser()) {
                        const walletOptionsHtml = `
                            <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
                                <button id="btnMetamask" class="swal2-styled">
                                    <img src="https://freelogopng.com/images/all_img/1683020955metamask-icon-png.png">
                                    Open with MetaMask
                                </button>
                                <button id="btnCoinbase" class="swal2-styled">
                                    <img src="https://nickelium.io/images2/coinbaseWallet.png">
                                    Open with Coinbase Wallet
                                </button>
                                <button id="btnKraken" class="swal2-styled">
                                <img src="https://nickelium.io/images2/krakenWallet.png">
                                    Open with Kraken Wallet
                                </button>
                                <button id="btnRabby" class="swal2-styled">
                                    <img src="https://nickelium.io/images2/rabbyWallet.png">
                                    Open with Rabby Wallet
                                </button>
                                <button id="btnTrust" class="swal2-styled">
                                    <img src="https://nickelium.io/images2/trustWallet.png">
                                    Open with Trust Wallet
                                </button>
                                
                                <button id="btnCancel" class="swal2-styled swal2-cancel">
                                    Cancel
                                </button>
                            </div>
                        `;
                        Swal.fire({
                            title: 'Connect Mobile Wallet',
                            html: walletOptionsHtml, // Use html property for custom content
                            showConfirmButton: false, // Hide the default SweetAlert2 confirm button
                            showCancelButton: false, // Hide the default SweetAlert2 cancel button
                            showCloseButton: true, // Show the 'X' in the corner for dismissal
                            didOpen: () => {
                                // Attach event listeners to your custom buttons after the modal is opened
                                document.getElementById('btnMetamask').addEventListener('click', () => {
                                    this.connectMobileWalletViaDeeplink('metamask');
                                    Swal.close(); // Close the modal after selection
                                });
                                document.getElementById('btnCoinbase').addEventListener('click', () => {
                                    this.connectMobileWalletViaDeeplink('coinbase');
                                    Swal.close();
                                });
                                /* REMOVED BINANCE EVENT LISTENER
                                document.getElementById('btnBinance').addEventListener('click', () => {
                                    this.connectMobileWalletViaDeeplink('binance');
                                    Swal.close();
                                });
                                */
                                document.getElementById('btnKraken').addEventListener('click', () => {
                                    this.connectMobileWalletViaDeeplink('kraken');
                                    Swal.close();
                                });
                                document.getElementById('btnRabby').addEventListener('click', () => {
                                    this.connectMobileWalletViaDeeplink('rabby');
                                    Swal.close();
                                });
                                document.getElementById('btnTrust').addEventListener('click', () => {
                                    this.connectMobileWalletViaDeeplink('trust');
                                    Swal.close();
                                });
                                document.getElementById('btnCancel').addEventListener('click', () => {
                                    Swal.close(); // Close the modal
                                });
                            }
                        }).then((result) => {
                            // This .then block will only be triggered if the modal is dismissed
                            // by clicking outside (if allowOutsideClick is true), or the 'X' button.
                            // Our custom buttons handle their own logic and close the modal directly.
                            if (result.dismiss === Swal.DismissReason.cancel || result.dismiss === Swal.DismissReason.close) {
                                // User dismissed the modal
                            }
                        });
                    } else {
                        Swal.fire({
                            title: 'Connect Wallet',
                            text: 'How would you like to connect?',
                            icon: 'info',
                            showDenyButton: true,
                            showConfirmButton: this.hasWalletInCurrentBrowser(),
                            confirmButtonText: 'Connect with browser of mobile wallet, or dektop browser extension,  (MetaMask, Rabby)',
                            denyButtonText: 'Scan QR Code (it will open the dapp to your mobile browser)',
                            showCancelButton: true,
                            cancelButtonText: 'Cancel'
                        }).then((result) => {
                            if (result.isConfirmed && this.hasWalletInCurrentBrowser()) {
                                this.connectInjectedWallet();
                            } else if (result.isDenied) {
                                this.showQrCodeOption();
                            } else if (!this.hasWalletInCurrentBrowser() && result.isConfirmed) {
                                this.showWalletError();
                            }
                        });
                    }
                });
            }
            if (this.hasWalletInCurrentBrowser()) {
                window.ethereum.on('accountsChanged', (accounts) => {
                    if (accounts.length === 0) {
                        this.state.isConnected = false;
                        this.state.userAccount = null;
                        localStorage.removeItem('walletConnected');
                        window.dispatchEvent(new Event('appState:connectionChanged'));
                    } else {
                        this.handleSuccessfulConnection(accounts[0]);
                    }
                    this.updateUI();
                });
                window.ethereum.on('chainChanged', (chainId) => {
                    window.location.reload();
                });
            }
        }
    }
    function initializeWhenReady() {
        const web3Loaded = typeof Web3 !== 'undefined';
        const swalLoaded = typeof Swal !== 'undefined';
        const qrcodeLoaded = typeof QRCode !== 'undefined';
        if (web3Loaded && swalLoaded && qrcodeLoaded) {
            WalletManager.init();
        } else {
            setTimeout(initializeWhenReady, 100);
        }
    }
    initializeWhenReady(); </script>
          </div>
        </div>
      </div></header>
    <section class="u-clearfix u-custom-color-4 u-section-1" id="sec-1963">
      <div class="data-layout-selected u-clearfix u-expanded-width u-gutter-10 u-layout-wrap u-layout-wrap-1">
        <div class="u-layout">
          <div class="u-layout-row">
            <div class="u-container-style u-layout-cell u-size-30 u-layout-cell-1">
              <div class="u-container-layout u-container-layout-1">
                <div class="custom-expanded u-align-center u-container-align-center u-container-align-center-lg u-container-align-center-xl u-container-style u-expanded-width u-group u-radius u-shading u-shape-round u-group-1">
                  <div class="u-container-layout u-container-layout-2">
                    <h4 class="u-text u-text-default u-text-1">Place buy order USDT</h4>
                    <div class="u-align-center u-clearfix u-custom-html u-expanded-width-lg u-expanded-width-xl u-custom-html-1"><!-- place buy order USDT with price validation -->
                      <style> input[type="text"] {
    /* Ensure no default browser appearance interferes */
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    /* Your desired text and background colors */
    color: white !important;
    background-color: #1B123E;
    /* Remove all borders */
    border: none !important; /* Explicitly remove all borders */
    outline: none !important; /* Remove the focus outline */
    /* Add padding for internal spacing and height control */
    padding: 12px 10px !important; /* Increased top/bottom padding to add height */
    /* Your desired border-radius */
    border-radius: 5px;
    /* Ensure padding doesn't increase total width/height beyond expectations */
    box-sizing: border-box; 
    /* Make inputs take full width of their container (optional, but good for form layout) */
    // width: 100%;
	  margin-top: 7px;
}
  #placeUSDTOrderButton {
    background: linear-gradient(to bottom right, #6211f0, #8c2dda);
    color: white;
    padding: 10px 60px;
    border: none;
    border-radius: 15px;
    font-size: 16px;
    cursor: pointer;
	transition: background 0.3s ease;
	margin-top: 5px;
  }
  #placeUSDTOrderButton:hover {
    background: linear-gradient(to bottom right, #8c2dda, #6211f0);
  } </style>
                      <div id="usdtBuyOrderContainer">
                        <input type="text" id="usdtPriceInput" placeholder="Price in USDT">
                        <input type="text" id="coinUSDTInput" placeholder="Amount of NCL (e.g., 1.5)">
                        <button id="placeUSDTOrderButton">Buy</button>
                      </div>
                      <script> // Contract addresses
const USDT_CONTRACT_ADDRESS = '0xdAC17F958D2ee523a2206206994597C13D831ec7';
const placeBuyContractAddress = '0x5E2aDEb82C79341C20fD94aC497f57ee5Ba50725';
const centralContractAddress = '0xca1D91233233f2cC0B0dC61a7c268dF5e223D081';
// Contract ABIs
const USDT_ABI = [
    {
        "constant": false,
        "inputs": [
            {"name": "_spender", "type": "address"},
            {"name": "_value", "type": "uint256"}
        ],
        "name": "approve",
        "outputs": [],
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {"name": "_owner", "type": "address"},
            {"name": "_spender", "type": "address"}
        ],
        "name": "allowance",
        "outputs": [
            {"name": "", "type": "uint256"}
        ],
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {"name": "_owner", "type": "address"}
        ],
        "name": "balanceOf",
        "outputs": [
            {"name": "", "type": "uint256"}
        ],
        "type": "function"
    },
	{
        "constant": true,
        "inputs": [],
        "name": "basisPointsRate",
        "outputs": [
            {"name": "", "type": "uint256"}
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "maximumFee",
        "outputs": [
            {"name": "", "type": "uint256"}
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
];
const placeBuyContractABI = [
    {
        "inputs": [
            {"internalType": "uint256", "name": "_price", "type": "uint256"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"}
        ],
        "name": "placeBuyOrderUSDT",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    }
];
const centralContractABI = [
    {
        "inputs": [],
        "name": "feePercentage",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "feeCap",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "LMEprice",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "tokenDecimals",
        "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "usdtPerEth",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    }
];
// Helper function to parse decimal input with exact precision
function parseDecimalInput(input, decimals) {
    if (!input || typeof input !== 'string') {
        throw new Error("Invalid input: must be a non-empty string");
    }
    input = input.trim();
    
    // Handle inputs that start with decimal point
    if (input.startsWith('.')) {
        input = '0' + input;
    }
    
    let [integerPart, fractionalPart = ''] = input.split('.');
    
    // Handle empty integer part
    if (integerPart === '') {
        integerPart = '0';
    }
    
    // Pad the fractional part with zeros to the desired number of decimals
    fractionalPart = fractionalPart.padEnd(decimals, '0');
    fractionalPart = fractionalPart.substring(0, decimals);
    
    const fullNumberString = integerPart + fractionalPart;
    const significantNumberString = fullNumberString.replace(/^0+/, '') || '0';
    
    if (significantNumberString === '0') {
        throw new Error("Amount is too small");
    }
    
    return BigInt(significantNumberString);
}
// Check USDT approval status
async function checkUSDTApproval(requiredAmount) {
    if (!window.appState?.web3 || !window.appState.userAccount) {
        return { isApproved: false, allowance: 0n };
    }
    
    try {
        const usdtContract = new window.appState.web3.eth.Contract(
            USDT_ABI,
            USDT_CONTRACT_ADDRESS
        );
        
        const allowance = await usdtContract.methods
            .allowance(window.appState.userAccount, placeBuyContractAddress)
            .call();
            
        return {
            isApproved: BigInt(allowance) >= BigInt(requiredAmount),
            allowance: BigInt(allowance)
        };
    } catch (error) {
        console.error('Error checking USDT approval:', error);
        return { isApproved: false, allowance: 0n };
    }
}
// Extract revert reason from error
async function extractRevertReason(error) {
    try {
        let revertReason = '';
        if (typeof error === 'string') {
            revertReason = error;
        } else if (error?.data?.message) {
            revertReason = error.data.message;
        } else if (error?.message) {
            revertReason = error.message;
        }
        
        const revertMatch = revertReason.match(/reverted:\s*(.*?)(\s*"|$)/);
        if (revertMatch) {
            revertReason = revertMatch[1].trim();
        }
        
        return revertReason || "Transaction failed (unknown reason)";
    } catch (e) {
        console.error("Error in extractRevertReason:", e);
        return "Transaction failed (could not determine reason)";
    }
}
// Main buy order function
async function placeUSDTBuyOrder() {
    let processingSwal = null;
    
    try {
        console.log('[1] Starting placeUSDTBuyOrder function');
        
        // Validate connection
        if (!window.appState?.isConnected || !window.appState.web3 || !window.appState.userAccount) {
            console.error('[2] Wallet not connected');
            throw new Error("Please connect your wallet first");
        }
        
        const web3 = window.appState.web3;
        console.log('[3] Web3 instance retrieved');
        
        // Initialize contracts
        console.log('[4] Initializing contracts...');
        const usdtContract = new web3.eth.Contract(USDT_ABI, USDT_CONTRACT_ADDRESS);
        const placeBuyContract = new web3.eth.Contract(placeBuyContractABI, placeBuyContractAddress);
        const centralContract = new web3.eth.Contract(centralContractABI, centralContractAddress);
        console.log('[5] Contracts initialized');
        
        // Get and validate inputs
        console.log('[6] Getting input values...');
        const usdtPriceInput = document.getElementById('usdtPriceInput').value.trim();
        const coinsInput = document.getElementById('coinUSDTInput').value.trim();
        
        console.log('[7] Validating inputs...');
        if (!usdtPriceInput || !coinsInput) {
            throw new Error("Please enter both price and amount");
        }
		
		const tokenAmountNumber = parseFloat(coinsInput);
if (tokenAmountNumber > 100000) {
    throw new Error("Maximum buy amount is 100,000 tokens");
}
if (tokenAmountNumber <= 0) {
    throw new Error("Token amount must be greater than 0");
}
        
        const decimalRegex = /^-?\d*\.?\d+$/;
        if (!decimalRegex.test(usdtPriceInput) || !decimalRegex.test(coinsInput)) {
            throw new Error("Please enter valid decimal numbers");
        }
        if (usdtPriceInput.includes('-') || coinsInput.includes('-')) {
            throw new Error("Price and amount must be positive");
        }
        
        // Validate decimal places
        const priceParts = usdtPriceInput.split('.');
        if (priceParts.length > 1 && priceParts[1].length > 6) {
            throw new Error("Price cannot have more than 6 decimal places");
        }
        
        const coinsParts = coinsInput.split('.');
        if (coinsParts.length > 1 && coinsParts[1].length > 3) {
            throw new Error("Amount cannot have more than 3 decimal places");
        }
		
		// Add this after your existing input validations
const minTokenAmount = 0.001; // Minimum 0.001 tokens
if (tokenAmountNumber < minTokenAmount) {
    throw new Error(`Minimum token amount is ${minTokenAmount}`);
}
const minPrice = 0.000001; // Minimum price 0.000001 USDT
const enteredPriceNumber = parseFloat(usdtPriceInput);
if (enteredPriceNumber < minPrice) {
    throw new Error(`Minimum price is ${minPrice} USDT`);
}
        
        // --- PRECISE CONVERSION USING EXACT STRING MANIPULATION ---
        console.log('[8] Converting inputs to precise BigInt values...');
        
        // USDT has 6 decimals
        const priceInUSDTUnits = parseDecimalInput(usdtPriceInput, 6);
        console.log('[8a] Price in USDT smallest units:', priceInUSDTUnits.toString());
        
        // Your NCL token has 3 decimals
        const tokenAmount = parseDecimalInput(coinsInput, 3);
        console.log('[8b] Token amount in smallest units:', tokenAmount.toString());
        
        
        // Calculate base cost (in USDT units, 6 decimals) with proper precision handling
console.log('[9] Calculating base cost with exact integer math...');
let baseCost = (priceInUSDTUnits * tokenAmount);
// Check if the result is too small to be meaningful
if (baseCost < (10n**3n)) {
    console.error('[9a] Amount too small for meaningful calculation');
    throw new Error("The amount is too small. Please increase the token amount.");
}
baseCost = baseCost / (10n**3n);
// Additional safety check
if (baseCost === 0n) {
    console.error('[9b] Base cost calculated as zero');
    throw new Error("The calculated cost is zero. Please increase either price or amount.");
}
console.log('[9c] Base cost (calculated exactly):', baseCost.toString());
        
        // Get USDT fee parameters
        console.log('[10] Getting USDT fee parameters...');
        const basisPointsRate = await usdtContract.methods.basisPointsRate().call();
        const maximumFee = await usdtContract.methods.maximumFee().call();
        console.log('[11] Got fee parameters - basisPointsRate:', basisPointsRate, 'maximumFee:', maximumFee);
        
        // Convert to BigInt
        const basisPointsRateBN = BigInt(basisPointsRate);
        const maximumFeeBN = BigInt(maximumFee);
        
        // Calculate exact fee USDT will charge
        console.log('[12] Calculating USDT fees...');
        let totalCost = baseCost;
        let fee = 0n;
        
        if (basisPointsRateBN > 0n) {
            console.log('[13] Calculating with basisPointsRate > 0');
            totalCost = (baseCost * 10000n) / (10000n - basisPointsRateBN);
            console.log('[14] First approximation totalCost:', totalCost.toString());
            
            fee = (totalCost * basisPointsRateBN) / 10000n;
            console.log('[15] Calculated fee:', fee.toString());
            
            if (maximumFeeBN > 0n && fee > maximumFeeBN) {
                console.log('[16] Applying maximum fee cap');
                fee = maximumFeeBN;
            }
            
            totalCost = baseCost + fee;
            console.log('[17] Final totalCost:', totalCost.toString());
        }
        
        // Check USDT balance
        console.log('[18] Checking USDT balance...');
        const usdtBalance = await usdtContract.methods.balanceOf(window.appState.userAccount).call();
        const usdtBalanceBN = BigInt(usdtBalance);
        const formattedBalance = (Number(usdtBalance)/1e6).toFixed(6);
        console.log('[19] USDT balance:', usdtBalanceBN.toString());
        
        if (usdtBalanceBN < totalCost) {
            console.error('[20] Insufficient USDT balance');
            throw new Error(`Insufficient USDT balance. Need ${(Number(totalCost)/1e6).toFixed(6)} USDT (including ${(Number(fee)/1e6).toFixed(6)} USDT fee), have ${formattedBalance} USDT`);
        }
        console.log('[21] USDT balance check passed');
        
        // Check USDT approval
        console.log('[22] Checking USDT approval...');
        let approvalStatus = await checkUSDTApproval(totalCost);
        console.log('[23] Approval status:', approvalStatus);
        
        // If not enough approval, handle it
        if (!approvalStatus.isApproved) {
            console.log('[24] Handling USDT approval...');
            const { value: approveResult } = await Swal.fire({
                title: 'USDT Approval Required',
                html: `
                    <div>
                        <p>You need to approve <b>${(Number(totalCost)/1e6).toFixed(6)} USDT</b> for this trade.</p>
                        <p>This includes:</p>
                        <ul>
                            <li>Base amount: ${(Number(baseCost)/1e6).toFixed(6)} USDT</li>
                            ${fee > 0n ? `<li>USDT transfer fee: ${(Number(fee)/1e6).toFixed(6)} USDT (${Number(basisPointsRate)/100}%)</li>` : ''}
                        </ul>
                        <p>This will:</p>
                        <ol>
                            <li>Reset any existing approval to 0 (security measure)</li>
                            <li>Approve the exact amount needed: ${(Number(totalCost)/1e6).toFixed(6)} USDT</li>
                        </ol>
                        <p><small>Note: Two transactions are required for security</small></p>
                    </div>
                `,
                icon: 'info',
                showCancelButton: true,
                confirmButtonText: 'Approve Exact Amount',
                confirmButtonColor: '#26a17b',
                showLoaderOnConfirm: true,
                preConfirm: async () => {
                    try {
                        console.log('[25] Starting approval process...');
                        // First transaction: Reset allowance to 0
                        const resetTx = await usdtContract.methods
                            .approve(placeBuyContractAddress, '0')
                            .send({ from: window.appState.userAccount });
                        console.log('Reset tx hash:', resetTx.transactionHash);
                        // WAIT for the reset transaction to be mined
                        const receipt = await web3.eth.getTransactionReceipt(resetTx.transactionHash);
                        if (!receipt.status) {
                            throw new Error("Reset transaction failed");
                        }
                        // Add a small delay for state propagation
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        // Second transaction: Approve exact amount needed
                        const approveTx = await usdtContract.methods
                            .approve(placeBuyContractAddress, totalCost.toString())
                            .send({ from: window.appState.userAccount });
                        console.log('Approve tx hash:', approveTx.transactionHash);
                        return approveTx;
                    } catch (error) {
                        console.error('[26] Approval failed:', error);
                        const revertReason = await extractRevertReason(error);
                        Swal.showValidationMessage(`Approval failed: ${revertReason}`);
                        return false;
                    }
                },
                allowOutsideClick: () => !Swal.isLoading()
            });
            
            if (!approveResult) {
                console.error('[27] Approval was cancelled or failed');
                throw new Error("Approval was cancelled or failed");
            }
            
            // Re-check approval after user completes it
            console.log('[28] Re-checking approval...');
            approvalStatus = await checkUSDTApproval(totalCost);
            
            if (!approvalStatus.isApproved) {
                console.error('[29] Approval still insufficient');
                throw new Error("Approval amount is still insufficient after approval");
            }
        }
        
        // Get contract parameters
        console.log('[30] Getting contract parameters...');
        const [LMEprice, feePercentage, feeCap, usdtPerEth] = await Promise.all([
            centralContract.methods.LMEprice().call(),
            centralContract.methods.feePercentage().call(),
            centralContract.methods.feeCap().call(),
            centralContract.methods.usdtPerEth().call()
        ]).then(results => results.map(r => BigInt(r)));
        
        console.log('[31] Contract parameters:', {
            LMEprice: LMEprice.toString(),
            feePercentage: feePercentage.toString(),
            feeCap: feeCap.toString(),
            usdtPerEth: usdtPerEth.toString()
        });
        
        const lmePriceUSDT = Number(LMEprice) / 1e6;
        console.log('[32] LME price in USDT:', lmePriceUSDT);
        
        // Convert the precisely calculated price for comparison
        const enteredPrice = Number(priceInUSDTUnits) / 1e6;
        if (enteredPrice < lmePriceUSDT) {
            console.error('[33] Price below LME');
            throw new Error(`Price must be ≥ ${lmePriceUSDT.toFixed(6)} USDT`);
        }
        
        // Calculate price in USDT units (6 decimals) - already have this from precise parsing
        console.log('[34] Using precise priceInUSDTUnits:', priceInUSDTUnits.toString());
        
        // Calculate raw fee in USDT (6 decimals)
        console.log('[35] Calculating owner fee...');
        const rawOwnerFeeInUSDT = (baseCost * feePercentage) / 10000n;
        console.log('[36] Raw owner fee in USDT:', rawOwnerFeeInUSDT.toString());
        
        // Convert raw USDT fee to ETH wei
        console.log('[37] Converting fee to ETH...');
        const rawOwnerFeeInETH = (rawOwnerFeeInUSDT * 10n**18n) / usdtPerEth;
        console.log('[38] Raw owner fee in ETH:', rawOwnerFeeInETH.toString());
        
        // Apply fee cap (which is in wei)
        console.log('[39] Applying fee cap...');
        const ownerFeeInETH = rawOwnerFeeInETH > feeCap ? feeCap : rawOwnerFeeInETH;
        console.log('[40] Final owner fee in ETH:', ownerFeeInETH.toString());
        
        // Convert feeCap to USDT for display
        const feeCapInUSDT = (feeCap * usdtPerEth) / 10n**18n;
        
        // Add 10% buffer to account for price fluctuations
        console.log('[41] Adding fee buffer...');
        const ownerFeeInETHWithBuffer = (ownerFeeInETH * 110n) / 100n;
        console.log('[42] Owner fee with buffer:', ownerFeeInETHWithBuffer.toString());
        
        // Estimate gas
        console.log('[43] Estimating gas...');
        const gasPrice = await web3.eth.getGasPrice();
        const gasPriceBN = BigInt(gasPrice);
        console.log('[44] Gas price:', gasPriceBN.toString());
        
        const gasEstimate = await placeBuyContract.methods
            .placeBuyOrderUSDT(priceInUSDTUnits.toString(), tokenAmount.toString())
            .estimateGas({
                from: window.appState.userAccount,
                value: ownerFeeInETHWithBuffer.toString()
            });
        
        const gasEstimateBN = BigInt(gasEstimate);
        console.log('[45] Gas estimate:', gasEstimateBN.toString());
        
        const gasWithBuffer = (gasEstimateBN * 120n) / 100n;
        console.log('[46] Gas with buffer:', gasWithBuffer.toString());
        
        const networkFee = gasWithBuffer * gasPriceBN;
        console.log('[47] Network fee:', networkFee.toString());
		
		console.log('[47b] Network fee in ETH:', web3.utils.fromWei(networkFee.toString(), 'ether'));
console.log('[47c] Gas estimate:', gasEstimate);
console.log('[47d] Gas price in ETH:', web3.utils.fromWei(gasPriceBN.toString(), 'ether'));
console.log('[47e] Gas price in Gwei:', web3.utils.fromWei(gasPriceBN.toString(), 'gwei'));
        
        const totalFees = ownerFeeInETHWithBuffer + networkFee;
        console.log('[48] Total fees:', totalFees.toString());
        
        // Check ETH balance
        console.log('[49] Checking ETH balance...');
        const ethBalance = await web3.eth.getBalance(window.appState.userAccount);
        const ethBalanceBN = BigInt(ethBalance);
        console.log('[50] ETH balance:', ethBalanceBN.toString());
        
        if (ethBalanceBN < totalFees) {
            console.error('[51] Insufficient ETH balance');
            const neededETH = web3.utils.fromWei(totalFees.toString(), 'ether');
            const hasETH = web3.utils.fromWei(ethBalance, 'ether');
            throw new Error(`Insufficient ETH for fees. Need ≈${neededETH} ETH (have ${hasETH} ETH)`);
        }
        console.log('[52] ETH balance check passed');
        
        // Determine if fee is capped
        const isCapped = rawOwnerFeeInETH > feeCap;
        console.log('[53] Is fee capped:', isCapped);
        
        // Show order confirmation with fees
        console.log('[54] Showing confirmation dialog...');
        const confirm = await Swal.fire({
            title: 'Confirm Buy Order',
            html: `
                <div style="text-align: left;">
                    <p><strong>Buying:</strong> ${coinsInput} tokens @ ${usdtPriceInput} USDT each</p>
                    <p><strong>Total Cost:</strong> ${(Number(baseCost)/1e6).toFixed(6)} USDT</p>
                    ${fee > 0n ? `<p><strong>USDT Transfer Fee:</strong> ${(Number(fee)/1e6).toFixed(6)} USDT (${Number(basisPointsRate)/100}%)</p>` : ''}
                    <p><strong>Current Rate:</strong> 1 ETH = ${(Number(usdtPerEth)/1e6).toFixed(2)} USDT</p>
                    <hr>
                    <p><strong>Fees:</strong></p>
                    ${isCapped ? `
                        <p>• <span style="text-decoration: line-through;">Original Fee: ${(Number(rawOwnerFeeInUSDT)/1e6).toFixed(6)} USDT (${web3.utils.fromWei(rawOwnerFeeInETH.toString(), 'ether')} ETH)</span></p>
                        <p>• <strong style="color: #FFC107;">Capped Fee:</strong> ${(Number(feeCapInUSDT)/1e6).toFixed(6)} USDT (${web3.utils.fromWei(feeCap.toString(), 'ether')} ETH)</p>
                    ` : `
                        <p>• Owner Fee: ${(Number(rawOwnerFeeInUSDT)/1e6).toFixed(6)} USDT (${web3.utils.fromWei(rawOwnerFeeInETH.toString(), 'ether')} ETH)</p>
                    `}
                    <p>• Network Fee: ~${web3.utils.fromWei(networkFee.toString(), 'ether')} ETH</p>
                    <p>• Fee Buffer: 10%</p>
                    <p><strong>Total Required:</strong> ${web3.utils.fromWei(totalFees.toString(), 'ether')} ETH</p>
                    ${isCapped ? `<p><small>Note: Fee has been capped at ${web3.utils.fromWei(feeCap.toString(), 'ether')} ETH</small></p>` : ''}
                </div>
            `,
            showCancelButton: true,
            confirmButtonText: 'Confirm Order',
            confirmButtonColor: '#26a17b',
            allowOutsideClick: false
        });
        
        if (!confirm.isConfirmed) {
            console.log('[55] Order confirmation cancelled');
            return;
        }
        
        // Execute order placement
        console.log('[56] Executing order placement...');
        processingSwal = Swal.fire({
            title: 'Processing Order...',
            allowOutsideClick: false,
            didOpen: () => Swal.showLoading()
        });
        
        const tx = await placeBuyContract.methods
            .placeBuyOrderUSDT(priceInUSDTUnits.toString(), tokenAmount.toString())
            .send({
                from: window.appState.userAccount,
                value: ownerFeeInETHWithBuffer.toString(),
                gas: gasWithBuffer.toString()
            });
            
        await processingSwal.close();
        console.log('[57] Order placement successful, tx hash:', tx.transactionHash);
        
        // Show success
        await Swal.fire({
            icon: 'success',
            title: 'Order Placed!',
            html: `Transaction: <a href="https://sepolia.etherscan.io/tx/${tx.transactionHash}" target="_blank">View on Etherscan</a>`,
            confirmButtonColor: '#26a17b'
        });
        
        // Clear form
        document.getElementById('usdtPriceInput').value = '';
        document.getElementById('coinUSDTInput').value = '';
        console.log('[58] Form cleared');
        
    } catch (error) {
        console.error('[ERROR] Caught error:', error);
        if (processingSwal) await processingSwal.close();
        
        let errorMsg = error.message;
        if (error.code === 4001) {
            errorMsg = "You rejected the transaction";
        } else if (error.message.includes("Approval was cancelled")) {
            errorMsg = "Token approval was cancelled";
        } else if (error.message.includes("Insufficient")) {
            errorMsg = error.message;
        } else if (error.data?.message) {
            errorMsg = error.data.message;
        }
        
        await Swal.fire({
            icon: 'error',
            title: 'Error',
            text: errorMsg,
            confirmButtonColor: '#26a17b'
        });
    }
}
// Attach event listener
document.getElementById('placeUSDTOrderButton').addEventListener('click', placeUSDTBuyOrder); </script><!-- end place buy order USDT with price validation -->
                    </div>
                  </div>
                </div>
                <div class="custom-expanded u-align-center u-container-align-center u-container-align-center-lg u-container-align-center-xl u-container-style u-custom-color-5 u-expanded-width u-group u-radius u-shape-round u-group-2">
                  <div class="u-container-layout u-container-layout-3">
                    <h4 class="u-text u-text-default u-text-2">Buy Orders&nbsp;USDT</h4>
                    <div class="custom-expanded u-clearfix u-custom-html u-expanded-width u-custom-html-2"><!-- Display Buy Orders USDT with Price Validation -->
                      <style> /* Container styling */
  #usdtBuyOrdersContainer {
    margin-top: 20px;
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    background-color: #121212;
    border-radius: 8px;
    padding: 2px;
  }
  /* Table styling */
  #usdtBuyOrdersTable {
    width: 100%;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    color: #e0e0e0;
  }
  /* Table header styling */
  #usdtBuyOrdersTable th {
    background-color: #1e1e1e;
    color: #ffffff;
    padding: 12px 10px;
    text-align: left;
    position: sticky;
    top: 0;
    font-weight: 600;
    border-bottom: 1px solid #333;
  }
  /* Table cell styling */
  #usdtBuyOrdersTable td {
    padding: 10px;
    border-bottom: 1px solid #333;
    word-break: break-word;
  }
  /* Zebra striping */
  #usdtBuyOrdersTable tr:nth-child(odd) {
    background-color: #1a1a1a;
  }
  #usdtBuyOrdersTable tr:nth-child(even) {
    background-color: #121212;
  }
  /* Hover effect */
  #usdtBuyOrdersTable tr:hover {
    background-color: #2a2a2a !important;
  }
  /* Button styling */
  .remove-order-btn,
  .update-order-btn {
    min-width: 70px;
    width: auto;
    padding: 6px 8px;
    border: none;
    border-radius: 4px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 500;
    margin-right: 5px;
    text-align: center;
    display: inline-block;
    box-sizing: border-box;
    line-height: 1.2;
    white-space: nowrap;
  }
  .remove-order-btn:hover {
    background-color: #FFA000;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  .update-order-btn:hover {
    background-color: #218838;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  .remove-order-btn {
    background-color: #FFC107;
    color: #000;
  }
  .update-order-btn {
    background-color: #28a745;
    color: white;
  }
  /* Order ID styling */
  .order-id {
    font-family: 'Courier New', monospace;
    color: #9e9e9e;
    font-size: 0.9em;
  }
  /* Column width adjustments */
  #usdtBuyOrdersTable th:nth-child(1),
  #usdtBuyOrdersTable td:nth-child(1) {
    width: 15%;
  }
  #usdtBuyOrdersTable th:nth-child(2),
  #usdtBuyOrdersTable td:nth-child(2) {
    width: 25%;
  }
  #usdtBuyOrdersTable th:nth-child(3),
  #usdtBuyOrdersTable td:nth-child(3) {
    width: 25%;
  }
  #usdtBuyOrdersTable th:nth-child(4),
  #usdtBuyOrdersTable td:nth-child(4) {
    width: 35%;
    min-width: 150px;
  }
  /* Mobile adjustments */
  @media (max-width: 768px) {
    .remove-order-btn,
    .update-order-btn {
      min-width: 60px;
      padding: 5px 6px;
      font-size: 13px;
      margin-right: 4px;
    }
    #usdtBuyOrdersTable th:nth-child(1),
    #usdtBuyOrdersTable td:nth-child(1) {
      width: 20%;
    }
    #usdtBuyOrdersTable th:nth-child(4),
    #usdtBuyOrdersTable td:nth-child(4) {
      width: 30%;
      min-width: 120px;
    }
  }
  @media (max-width: 480px) {
    .remove-order-btn,
    .update-order-btn {
      min-width: 55px;
      padding: 4px 5px;
      font-size: 12px;
    }
    .remove-order-btn {
      min-width: 50px;
      padding: 4px;
      font-size: 11px;
    }
    .update-order-btn {
      min-width: 50px;
      padding: 4px;
      font-size: 11px;
    }
  } </style>
                      <div id="usdtBuyOrdersContainer">
                        <table id="usdtBuyOrdersTable">
                          <thead>
                            <tr>
                              <th>ID</th>
                              <th>Price</th>
                              <th>Amount</th>
                              <th>Actions</th>
                            </tr>
                          </thead>
                          <tbody id="usdtBuyOrdersList"><!-- Orders will be inserted here dynamically --></tbody>
                        </table>
                      </div>
                      <script> // USDT Buy Orders Display and Management
const USDTBuyOrdersManager = (function() {
  // Contract configuration
  const config = {
    buyOrdersContractAddress: '0x5E2aDEb82C79341C20fD94aC497f57ee5Ba50725',
    centralContractAddress: '0xca1D91233233f2cC0B0dC61a7c268dF5e223D081',
    usdtContractAddress: '0xdAC17F958D2ee523a2206206994597C13D831ec7',
    
    buyOrdersContractABI: [
      {
        "inputs": [],
        "name": "getBuyOrdersUSDT",
        "outputs": [
          {
            "components": [
              { "internalType": "uint256", "name": "orderID", "type": "uint256" },
              { "internalType": "address payable", "name": "user", "type": "address" },
              { "internalType": "uint256", "name": "price", "type": "uint256" },
              { "internalType": "uint256", "name": "amount", "type": "uint256" },
              { "internalType": "uint256", "name": "fulfilledAmount", "type": "uint256" },
              { "internalType": "enum SharedStructs.AssetType", "name": "assetType", "type": "uint8" },
              { "internalType": "enum SharedStructs.PaymentMethod", "name": "priceCurrency", "type": "uint8" },
              { "internalType": "bool", "name": "authorizedBuyersOnly", "type": "bool" }
            ],
            "internalType": "struct SharedStructs.Order[]",
            "name": "",
            "type": "tuple[]"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [{"internalType": "uint256", "name": "orderID", "type": "uint256"}],
        "name": "RemoveOrder",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {"internalType": "uint256", "name": "orderID", "type": "uint256"},
          {"internalType": "uint256", "name": "newPrice", "type": "uint256"}
        ],
        "name": "changeBuyOrderPriceUSDT",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      }
    ],
    
    usdtContractABI: [
      {
        "constant": false,
        "inputs": [
            {"name": "_spender", "type": "address"},
            {"name": "_value", "type": "uint256"}
        ],
        "name": "approve",
        "outputs": [],
        "type": "function"
    },
      {
        "constant": true,
        "inputs": [
            {"name": "_owner", "type": "address"},
            {"name": "_spender", "type": "address"}
        ],
        "name": "allowance",
        "outputs": [
            {"name": "", "type": "uint256"}
        ],
        "type": "function"
    },
	{
        "constant": true,
        "inputs": [],
        "name": "basisPointsRate",
        "outputs": [
            {"name": "", "type": "uint256"}
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "maximumFee",
        "outputs": [
            {"name": "", "type": "uint256"}
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
	{
        "constant": true,
        "inputs": [
            {"name": "_owner", "type": "address"}
        ],
        "name": "balanceOf",
        "outputs": [
            {"name": "", "type": "uint256"}
        ],
        "type": "function"
    }
    ],
    
    // Updated central contract ABI with LMEprice
    centralContractABI: [
      {
        "inputs": [],
        "name": "feePercentage",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "feeCap",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "LMEprice",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
      }
    ]
  };
  
  let processingSwal = null;
  
  // Helper function to format units to price string with specified decimals
  function formatUnitsToPrice(units, decimals) {
    const unitsBigInt = BigInt(units);
    const divisor = 10n ** BigInt(decimals);
    
    const integerPart = unitsBigInt / divisor;
    const fractionalPart = unitsBigInt % divisor;
    
    if (fractionalPart === 0n) {
      return integerPart.toString();
    }
    
    const fractionalStr = fractionalPart.toString().padStart(decimals, '0');
    // Remove trailing zeros
    const trimmedFractional = fractionalStr.replace(/0+$/, '');
    return `${integerPart}.${trimmedFractional}`;
  }
  
  // Format USDT price (6 decimals)
  function formatUSDTPrice(usdtUnits) {
    try {
      return formatUnitsToPrice(BigInt(usdtUnits), 6);
    } catch {
      return '0';
    }
  }
  
  // Format token amount (3 decimals)
  function formatTokenAmount(tokenAmount) {
    try {
      return formatUnitsToPrice(BigInt(tokenAmount), 3);
    } catch {
      return '0';
    }
  }
  
  // Helper function to parse price string to units with specified decimals
  function parsePriceToUnits(priceString, decimals) {
    if (!priceString || priceString.trim() === '') {
      throw new Error('Invalid price amount');
    }
    
    const trimmed = priceString.trim();
    if (!trimmed.includes('.')) {
      return BigInt(trimmed) * (10n ** BigInt(decimals));
    }
    
    const [integerPart, decimalPart] = trimmed.split('.');
    if (decimalPart.length > decimals) {
      throw new Error(`Price cannot have more than ${decimals} decimal places`);
    }
    
    const paddedDecimals = decimalPart.padEnd(decimals, '0').substring(0, decimals);
    return BigInt(integerPart) * (10n ** BigInt(decimals)) + BigInt(paddedDecimals);
  }
  
  // Remove order function
  async function removeBuyOrder(orderId) {
    if (!window.appState?.isConnected) {
        await Swal.fire('Error', 'Please connect your wallet first', 'error');
        return;
    }
    
    try {
        const confirmResult = await Swal.fire({
            title: 'Confirm Removal',
            text: 'Are you sure you want to remove this buy order?',
            icon: 'warning',
            showCancelButton: true,
            confirmButtonColor: '#FFC107',
            confirmButtonText: 'Yes, remove it!',
            cancelButtonText: 'Cancel'
        });
        
        if (!confirmResult.isConfirmed) return;
        
        processingSwal = Swal.fire({
            title: 'Removing Buy Order...',
            allowOutsideClick: false,
            didOpen: () => Swal.showLoading()
        });
        
        const contract = new window.appState.web3.eth.Contract(
            config.buyOrdersContractABI,
            config.buyOrdersContractAddress
        );
        
        const tx = await contract.methods
            .RemoveOrder(orderId)
            .send({ from: window.appState.userAccount });
        
        await processingSwal.close();
        
        await Swal.fire({
            icon: 'success',
            title: 'Order Removed!',
            html: `Transaction: <small>${tx.transactionHash}</small>`,
            confirmButtonColor: '#FFC107'
        });
        
        refreshUSDTBuyOrders();
    } catch (error) {
        if (processingSwal) await processingSwal.close();
        
        let errorMsg = error.message;
        if (error.code === 4001) errorMsg = "You rejected the transaction";
        else if (error.receipt?.status === false) errorMsg = "Transaction failed on-chain";
        else if (error.message.includes("Only order owner can remove")) {
            errorMsg = "You can only remove your own orders";
        }
        
        await Swal.fire({
            icon: 'error',
            title: 'Removal Failed',
            text: errorMsg,
            confirmButtonColor: '#FFC107'
        });
    }
  }
  
  // Update USDT order price with price validation and USDT fee handling
  async function updateUSDTOrderPrice(orderId, currentPriceUSDT) {
    if (!window.appState?.isConnected) {
        await Swal.fire('Error', 'Please connect your wallet first', 'error');
        return;
    }
    
    try {
        // Get current LME price first
        const centralContract = new window.appState.web3.eth.Contract(
            config.centralContractABI,
            config.centralContractAddress
        );
        const LMEprice = await centralContract.methods.LMEprice().call();
        const lmePriceUSDT = formatUnitsToPrice(BigInt(LMEprice), 6);
        
        const { value: newPriceUSDT } = await Swal.fire({
            title: 'Update Order Price',
            html: `
                <div>
                    <p>Current Price: <strong>${currentPriceUSDT} USDT</strong></p>
                    <p>Minimum Allowed Price: <strong>${lmePriceUSDT} USDT</strong></p>
                    <input 
                        id="newPriceInput" 
                        type="text" 
                        class="swal2-input" 
                        placeholder="Enter new price (USDT)"
                        pattern="[0-9.]+"
                    >
                </div>
            `,
            focusConfirm: false,
            showCancelButton: true,
            confirmButtonText: 'Update Price',
            cancelButtonText: 'Cancel',
            preConfirm: () => {
                const input = Swal.getPopup().querySelector('#newPriceInput');
                const value = input.value.trim();
                
                if (!value || value === '') {
                    Swal.showValidationMessage('Please enter a valid price');
                    return false;
                }
                
                try {
                    // Validate and convert price using safe parsing
                    const newPriceInUSDTUnits = parsePriceToUnits(value, 6);
                    const lmePriceInUSDTUnits = parsePriceToUnits(lmePriceUSDT, 6);
                    
                    if (newPriceInUSDTUnits < lmePriceInUSDTUnits) {
                        Swal.showValidationMessage(`Price must be ≥ ${lmePriceUSDT} USDT`);
                        return false;
                    }
                    
                    return value;
                } catch (error) {
                    Swal.showValidationMessage(error.message);
                    return false;
                }
            }
        });
        
        if (!newPriceUSDT) return;
        
        // Initialize contracts
        const buyOrdersContract = new window.appState.web3.eth.Contract(
            config.buyOrdersContractABI,
            config.buyOrdersContractAddress
        );
        
        const usdtContract = new window.appState.web3.eth.Contract(
            config.usdtContractABI,
            config.usdtContractAddress
        );
        
        // Get current order details
        const orders = await buyOrdersContract.methods.getBuyOrdersUSDT().call();
        const order = orders.find(o => o.orderID.toString() === orderId.toString());
        
        if (!order) throw new Error('Order not found');
        
        // Convert prices to USDT units (6 decimals) using safe parsing
        const newPriceInUSDTUnits = parsePriceToUnits(newPriceUSDT, 6);
        const currentPriceInUSDTUnits = parsePriceToUnits(currentPriceUSDT, 6);
        
        // Calculate cost differences
        const remainingAmount = BigInt(order.amount);
        const oldCost = (currentPriceInUSDTUnits * remainingAmount) / 1000n;
        const newCost = (newPriceInUSDTUnits * remainingAmount) / 1000n;
        
        // Only proceed if new price is higher (requires additional USDT)
        if (newPriceInUSDTUnits <= currentPriceInUSDTUnits) {
            // Price decrease or same - no additional USDT needed
            processingSwal = Swal.fire({
                title: 'Processing Update...',
                allowOutsideClick: false,
                didOpen: () => Swal.showLoading()
            });
            
            const tx = await buyOrdersContract.methods
                .changeBuyOrderPriceUSDT(orderId, newPriceInUSDTUnits.toString())
                .send({ from: window.appState.userAccount });
            
            await processingSwal.close();
            
            await Swal.fire({
                icon: 'success',
                title: 'Price Updated!',
                html: `Transaction: <small>${tx.transactionHash}</small>`,
                confirmButtonColor: '#28a745'
            });
            
            refreshUSDTBuyOrders();
            return;
        }
        
        // Price increase - calculate additional USDT needed including fees
        const baseCostIncrease = newCost - oldCost;
        
        // Get USDT fee parameters
        const basisPointsRate = BigInt(await usdtContract.methods.basisPointsRate().call());
        const maximumFee = BigInt(await usdtContract.methods.maximumFee().call());
        
        // Calculate exact fee USDT will charge
        let additionalCost = baseCostIncrease;
        let fee = 0n;
        
        if (basisPointsRate > 0n) {
            // First approximation
            additionalCost = (baseCostIncrease * 10000n) / (10000n - basisPointsRate);
            
            // Adjust for exact match with USDT's calculation
            fee = (additionalCost * basisPointsRate) / 10000n;
            if (maximumFee > 0n && fee > maximumFee) {
                fee = maximumFee;
            }
            
            // Recalculate additionalCost to ensure escrow gets EXACTLY baseCostIncrease
            additionalCost = baseCostIncrease + fee;
        }
        
        // Check USDT balance
        const usdtBalance = BigInt(await usdtContract.methods.balanceOf(window.appState.userAccount).call());
        if (usdtBalance < additionalCost) {
            throw new Error(`Insufficient USDT balance. Need ${formatUnitsToPrice(additionalCost, 6)} USDT (including ${formatUnitsToPrice(fee, 6)} USDT fee)`);
        }
        
        // Check USDT allowance
        const allowance = BigInt(await usdtContract.methods
            .allowance(window.appState.userAccount, config.buyOrdersContractAddress)
            .call());
        
        // Show approval dialog if needed
        if (allowance < additionalCost) {
            await processingSwal?.close();
            
            const { isConfirmed } = await Swal.fire({
                title: 'Additional USDT Approval Needed',
                html: `
                    <div>
                        <p>You need to approve <b>${formatUnitsToPrice(additionalCost, 6)} USDT</b> to complete this price update.</p>
                        <p>This includes:</p>
                        <ul>
                            <li>Base amount increase: ${formatUnitsToPrice(baseCostIncrease, 6)} USDT</li>
                            ${fee > 0n ? `<li>USDT transfer fee: ${formatUnitsToPrice(fee, 6)} USDT (${Number(basisPointsRate)/100}%)</li>` : ''}
                        </ul>
                        <p><small>Current price: ${currentPriceUSDT} USDT → New price: ${newPriceUSDT} USDT</small></p>
                        <p><small>This will perform two transactions:</small></p>
                        <ol style="padding-left: 20px; margin-top: 5px;">
                            <li><small>Reset allowance to 0 (security measure)</small></li>
                            <li><small>Approve the exact amount needed</small></li>
                        </ol>
                    </div>
                `,
                icon: 'info',
                showCancelButton: true,
                confirmButtonText: 'Approve USDT',
                confirmButtonColor: '#26a17b',
                cancelButtonText: 'Cancel'
            });
            
            if (!isConfirmed) return;
            
            processingSwal = Swal.fire({
                title: 'Approving USDT...',
                didOpen: () => Swal.showLoading(),
                allowOutsideClick: false
            });
            
            try {
                // First transaction: Reset allowance to 0
                await usdtContract.methods
                    .approve(config.buyOrdersContractAddress, '0')
                    .send({ from: window.appState.userAccount });
                
                // Second transaction: Approve exact additional amount needed
                const approveTx = await usdtContract.methods
                    .approve(config.buyOrdersContractAddress, additionalCost.toString())
                    .send({ from: window.appState.userAccount });
                
                await Swal.fire({
                    icon: 'success',
                    title: 'USDT Approved!',
                    html: `Transaction: <small>${approveTx.transactionHash}</small>`,
                    confirmButtonColor: '#26a17b'
                });
            } catch (error) {
                await processingSwal.close();
                throw error;
            }
        }
        
        // Execute the price update
        processingSwal = Swal.fire({
            title: 'Updating Order...',
            didOpen: () => Swal.showLoading(),
            allowOutsideClick: false
        });
        
        const tx = await buyOrdersContract.methods
            .changeBuyOrderPriceUSDT(orderId, newPriceInUSDTUnits.toString())
            .send({ from: window.appState.userAccount });
        
        await processingSwal.close();
        
        await Swal.fire({
            icon: 'success',
            title: 'Price Updated!',
            html: `Transaction: <small>${tx.transactionHash}</small>`,
            confirmButtonColor: '#28a745'
        });
        
        refreshUSDTBuyOrders();
        
    } catch (error) {
        if (processingSwal) await processingSwal.close();
        
        let errorMsg = error.message;
        if (error.code === 4001) errorMsg = "You rejected the transaction";
        else if (error.receipt?.status === false) errorMsg = "Transaction failed on-chain";
        else if (error.message.includes("Only the owner can change the price")) {
            errorMsg = "You can only update your own orders";
        } else if (error.message.includes("Insufficient USDT")) {
            errorMsg = error.message;
        } else if (error.message.includes("Price must be ≥")) {
            errorMsg = error.message;
        }
        
        await Swal.fire({
            icon: 'error',
            title: 'Update Failed',
            text: errorMsg,
            confirmButtonColor: '#28a745'
        });
    }
  }
  
  // Render USDT buy orders
  async function renderUSDTBuyOrders(orders) {
    const ordersList = document.getElementById('usdtBuyOrdersList');
    
    if (!orders || orders.length === 0) {
        ordersList.innerHTML = '<tr><td colspan="4" style="text-align: center;">No USDT buy orders available</td></tr>';
        return;
    }
    
    const fragment = document.createDocumentFragment();
    
    for (const order of orders) {
        const row = document.createElement('tr');
        
        // Check if this order belongs to the current user
        const isUserOrder = window.appState.userAccount && 
                           order.user.toLowerCase() === window.appState.userAccount.toLowerCase();
        
        const currentPriceUSDT = formatUSDTPrice(order.price);
        const tokenAmount = formatTokenAmount(order.amount);
        
        row.innerHTML = `
            <td class="order-id">${order.orderID}</td>
            <td>${currentPriceUSDT} USDT</td>
            <td>${tokenAmount}</td>
            <td class="order-actions"></td>
        `;
        
        if (isUserOrder) {
            const actionsCell = row.querySelector('.order-actions');
            
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-order-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.onclick = (e) => {
                e.preventDefault();
                removeBuyOrder(order.orderID);
            };
            
            const updateBtn = document.createElement('button');
            updateBtn.className = 'update-order-btn';
            updateBtn.textContent = 'Update';
            updateBtn.onclick = (e) => {
                e.preventDefault();
                updateUSDTOrderPrice(order.orderID, currentPriceUSDT);
            };
            
            actionsCell.appendChild(removeBtn);
            actionsCell.appendChild(updateBtn);
        }
        
        fragment.appendChild(row);
    }
    
    ordersList.innerHTML = '';
    ordersList.appendChild(fragment);
  }
  
  // Fetch and refresh USDT buy orders
  async function refreshUSDTBuyOrders() {
    if (!window.appState?.web3) {
      document.getElementById('usdtBuyOrdersList').innerHTML = 
        '<tr><td colspan="4" style="text-align: center;">Wallet not connected</td></tr>';
      return;
    }
    
    try {
      const contract = new window.appState.web3.eth.Contract(
        config.buyOrdersContractABI,
        config.buyOrdersContractAddress
      );
      
      const orders = await contract.methods.getBuyOrdersUSDT().call();
      await renderUSDTBuyOrders(orders);
    } catch (error) {
      console.error('Error fetching USDT buy orders:', error);
      document.getElementById('usdtBuyOrdersList').innerHTML = 
        '<tr><td colspan="4" style="text-align: center;">Error loading orders</td></tr>';
    }
  }
  
  // Initialize polling
  function startPolling() {
    refreshUSDTBuyOrders();
    return setInterval(refreshUSDTBuyOrders, 5000);
  }
  
  let pollInterval = null;
  
  return {
    refreshUSDTBuyOrders,
    removeBuyOrder,
    updateUSDTOrderPrice,
    startPolling
  };
})();
// Initialize when wallet is ready
function initUSDTBuyOrders() {
  if (window.appState?.isConnected) {
    USDTBuyOrdersManager.refreshUSDTBuyOrders();
    if (!window.usdtBuyOrdersPollStarted) {
      window.usdtBuyOrdersPollStarted = true;
      USDTBuyOrdersManager.startPolling();
    }
  }
}
// Set up event listeners
window.addEventListener('appState:connectionChanged', initUSDTBuyOrders);
document.addEventListener('DOMContentLoaded', function() {
  if (window.appState?.isConnected) {
    initUSDTBuyOrders();
  }
  window.addEventListener('appState:connectionChanged', initUSDTBuyOrders);
});
// Make refresh function available globally
window.refreshUSDTBuyOrders = USDTBuyOrdersManager.refreshUSDTBuyOrders; </script><!-- end display Buy Orders USDT with Price Validation -->
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="u-container-style u-layout-cell u-size-30 u-layout-cell-2">
              <div class="u-container-layout u-valign-bottom-lg u-valign-bottom-sm u-container-layout-4">
                <div class="custom-expanded u-align-center u-container-align-center u-container-align-center-lg u-container-align-center-xl u-container-style u-expanded-width u-group u-radius u-shading u-shape-round u-group-3">
                  <div class="u-container-layout u-container-layout-5">
                    <h4 class="u-text u-text-default u-text-3">Place sell order&nbsp;USDT</h4>
                    <div class="u-align-center u-clearfix u-custom-html u-expanded-width-lg u-expanded-width-xl u-custom-html-3"><!-- place sell order USDT-->
                      <style> #placeUSDTOrderButton2 {
    background: linear-gradient(to bottom right, #6211f0, #8c2dda);
    color: white;
    padding: 10px 60px;
    border: none;
    border-radius: 15px;
    font-size: 16px;
    cursor: pointer;
	transition: background 0.3s ease;
	margin-top: 5px;
  }
  #placeUSDTOrderButton2:hover {
    background: linear-gradient(to bottom right, #8c2dda, #6211f0);
  }
  input[type="text"] {
    color: black;
  }
  .approve-btn {
    background-color: purple;
    color: white;
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    font-size: 14px;
    cursor: pointer;
    margin-top: 10px;
  }
  .approve-btn:hover {
    background-color: #6a1b9a;
  } </style>
                      <div id="usdtSellOrderContainer">
                        <input type="text" id="sellUSDTPriceInput" placeholder="Price in USDT">
                        <input type="text" id="sellCoinUSDTInput" placeholder="Amount of NCL (e.g., 1.5)">
                        <button id="placeUSDTOrderButton2">Sell</button>
                      </div>
                      <script> // Contract addresses
const tokenContractAddress = '0x5E2aDEb82C79341C20fD94aC497f57ee5Ba50725';
const placeSellContractAddress = '0x5E2aDEb82C79341C20fD94aC497f57ee5Ba50725';
// Contract ABIs
const tokenContractABI = [
    {
        "inputs": [
            {"internalType": "address", "name": "spender", "type": "address"},
            {"internalType": "uint256", "name": "value", "type": "uint256"}
        ],
        "name": "approve",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "address", "name": "owner", "type": "address"},
            {"internalType": "address", "name": "spender", "type": "address"}
        ],
        "name": "allowance",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    }
];
const placeSellContractABI = [
    {
        "inputs": [
            {"internalType": "uint256", "name": "_price", "type": "uint256"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"}
        ],
        "name": "placeSellOrderUSDT",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    }
];
// Helper function to format token amount with exact decimals
function formatTokenAmount(amount, decimals = 3) {
    const amountNum = Number(amount);
    const divisor = 10 ** decimals;
    return (amountNum / divisor).toFixed(decimals);
}
// Helper function to format USDT with exact decimals
function formatUSDTExact(amount) {
    return (Number(amount) / 1e6).toFixed(6);
}
// Helper function to format USDT (6 decimals)
function formatUSDT(amount) {
    return (Number(amount) / 1e6).toLocaleString('en-US', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 6
    });
}
// Precise decimal input parser
function parseDecimalInput(input, decimals) {
    if (!input || typeof input !== 'string') {
        throw new Error("Invalid input: must be a non-empty string");
    }
    input = input.trim();
    let [integerPart, fractionalPart = ''] = input.split('.');
    
    // Pad the fractional part with zeros to the desired number of decimals
    fractionalPart = fractionalPart.padEnd(decimals, '0');
    fractionalPart = fractionalPart.substring(0, decimals);
    const fullNumberString = integerPart + fractionalPart;
    const significantNumberString = fullNumberString.replace(/^0+/, '') || '0';
    
    return BigInt(significantNumberString);
}
// Check token approval status - checking approval to user's own address
async function checkTokenApproval(requiredAmount) {
    if (!window.appState?.web3 || !window.appState.userAccount) {
        return { isApproved: false, allowance: 0n };
    }
    
    try {
        const tokenContract = new window.appState.web3.eth.Contract(
            tokenContractABI,
            tokenContractAddress
        );
        
        // Check approval from user to themselves
        const allowance = await tokenContract.methods
            .allowance(window.appState.userAccount, window.appState.userAccount)
            .call();
            
        return {
            isApproved: BigInt(allowance) >= BigInt(requiredAmount),
            allowance: BigInt(allowance)
        };
    } catch (error) {
        console.error('Error checking approval:', error);
        return { isApproved: false, allowance: 0n };
    }
}
// Handle token approval - approving to user's own address
async function handleTokenApproval(requiredAmount) {
    if (!window.appState?.web3 || !window.appState.userAccount) {
        throw new Error("Please connect your wallet first");
    }
    
    const tokenContract = new window.appState.web3.eth.Contract(
        tokenContractABI,
        tokenContractAddress
    );
    
    // Show approval dialog with button - FIXED: use requiredAmount instead of tokenAmount
    const { value: approveResult } = await Swal.fire({
        title: 'Token Approval Required',
        html: `
            <div>
                <p>You need to approve <b>${formatTokenAmount(requiredAmount, 3)} tokens</b> for trading.</p>
                <p>This requires a wallet transaction.</p>
            </div>
        `,
        icon: 'info',
        showCancelButton: true,
        confirmButtonText: 'Approve Tokens',
        confirmButtonColor: 'purple',
        showLoaderOnConfirm: true,
        preConfirm: async () => {
            try {
                // Approve from user to themselves
                const tx = await tokenContract.methods
                    .approve(window.appState.userAccount, requiredAmount.toString())
                    .send({ from: window.appState.userAccount });
                return tx;
            } catch (error) {
                Swal.showValidationMessage(`Approval failed: ${error.message}`);
                return false;
            }
        },
        allowOutsideClick: () => !Swal.isLoading()
    });
    
    if (!approveResult) {
        throw new Error("Approval was cancelled or failed");
    }
    
    return true;
}
// Main sell order function
async function placeSellOrder() {
    let processingSwal = null;
    
    try {
        // Validate connection
        if (!window.appState?.isConnected || !window.appState.web3 || !window.appState.userAccount) {
            throw new Error("Please connect your wallet first");
        }
        
        const web3 = window.appState.web3;
        
        // Initialize contracts
        const tokenContract = new web3.eth.Contract(tokenContractABI, tokenContractAddress);
        const placeSellContract = new web3.eth.Contract(placeSellContractABI, placeSellContractAddress);
        const centralContract = new web3.eth.Contract(centralContractABI, centralContractAddress);
        
        // Get and validate inputs
        const usdtPriceInput = document.getElementById('sellUSDTPriceInput').value.trim();
        const coinsInput = document.getElementById('sellCoinUSDTInput').value.trim();
        
        // Validate inputs
        if (!usdtPriceInput || !coinsInput) {
            throw new Error("Please enter both price and amount");
        }
		
		const tokenAmountNumber = parseFloat(coinsInput);
if (tokenAmountNumber > 100000) {
    throw new Error("Maximum sell amount is 100,000 tokens");
}
if (tokenAmountNumber <= 0) {
    throw new Error("Token amount must be greater than 0");
}
        
        if (usdtPriceInput.includes('.')) {
            const priceDecimals = usdtPriceInput.split('.')[1].length;
            if (priceDecimals > 6) {
                throw new Error(`Price cannot have more than 6 decimal places (you entered ${priceDecimals})`);
            }
        }
        
        if (coinsInput.includes('.')) {
            const amountDecimals = coinsInput.split('.')[1].length;
            if (amountDecimals > 3) {
                throw new Error(`Amount cannot have more than 3 decimal places (you entered ${amountDecimals})`);
            }
        }
        
        // Use precise parsing instead of floating point
        const priceInUSDTUnits = parseDecimalInput(usdtPriceInput, 6);
        const tokenAmount = parseDecimalInput(coinsInput, 3);
        
        // Check token balance
        const tokenBalance = await tokenContract.methods.balanceOf(window.appState.userAccount).call();
        const preciseBalance = formatTokenAmount(tokenBalance, 3);
        const preciseNeeded = formatTokenAmount(tokenAmount, 3);
        
        if (BigInt(tokenBalance) < tokenAmount) {
            throw new Error(`Insufficient token balance. Need ${preciseNeeded}, have ${preciseBalance}`);
        }
        
        // Check token approval
        let approvalStatus = await checkTokenApproval(tokenAmount);
        
        // If not enough approval, handle it
        if (!approvalStatus.isApproved) {
            // Show approval dialog
            await handleTokenApproval(tokenAmount);
            
            // Re-check approval after user completes it
            approvalStatus = await checkTokenApproval(tokenAmount);
            
            if (!approvalStatus.isApproved) {
                throw new Error("Approval amount is still insufficient after approval");
            }
        }
        
        // Get contract parameters
        const [LMEprice, feePercentage, feeCap, usdtPerEth] = await Promise.all([
            centralContract.methods.LMEprice().call(),
            centralContract.methods.feePercentage().call(),
            centralContract.methods.feeCap().call(),
            centralContract.methods.usdtPerEth().call()
        ]);
        
        const lmePriceUSDT = Number(LMEprice) / 1e6;
        const enteredPrice = Number(priceInUSDTUnits) / 1e6;
        
        if (enteredPrice < lmePriceUSDT) {
            throw new Error(`Price must be ≥ ${lmePriceUSDT.toFixed(6)} USDT`);
        }
        
        // Calculate order value in USDT (6 decimals)
        const orderValue = (priceInUSDTUnits * tokenAmount) / 1000n;
        
        // Calculate raw fee in USDT (6 decimals)
        const rawOwnerFeeInUSDT = (orderValue * BigInt(feePercentage)) / 10000n;
        
        // Convert raw USDT fee to ETH wei
        const rawOwnerFeeInETH = (rawOwnerFeeInUSDT * BigInt(1e18)) / BigInt(usdtPerEth);
        
        // Apply fee cap (which is in wei)
        const ownerFeeInETH = rawOwnerFeeInETH > BigInt(feeCap) ? BigInt(feeCap) : rawOwnerFeeInETH;
        
        // Convert feeCap to USDT for display
        const feeCapInUSDT = (BigInt(feeCap) * BigInt(usdtPerEth)) / BigInt(1e18);
        
        // Add 10% buffer to account for price fluctuations
        const ownerFeeInETHWithBuffer = (ownerFeeInETH * 110n) / 100n;
        
        // Estimate gas
        const gasPrice = BigInt(await web3.eth.getGasPrice());
        const gasEstimate = await placeSellContract.methods
            .placeSellOrderUSDT(priceInUSDTUnits.toString(), tokenAmount.toString())
            .estimateGas({
                from: window.appState.userAccount,
                value: ownerFeeInETHWithBuffer.toString()
            });
            
        const gasWithBuffer = (BigInt(gasEstimate) * 120n) / 100n;
        const networkFee = gasWithBuffer * gasPrice;
        const totalFees = ownerFeeInETHWithBuffer + networkFee;
        
        // Check ETH balance
        const ethBalance = await web3.eth.getBalance(window.appState.userAccount);
        if (BigInt(ethBalance) < totalFees) {
            const neededETH = web3.utils.fromWei(totalFees.toString(), 'ether');
            const hasETH = web3.utils.fromWei(ethBalance, 'ether');
            throw new Error(`Insufficient ETH for fees. Need ≈${neededETH} ETH (have ${hasETH} ETH)`);
        }
        
        // Prepare precise values for display
        const preciseCoins = formatTokenAmount(tokenAmount, 3);
        const precisePrice = formatUSDTExact(priceInUSDTUnits);
        const preciseTotalValue = formatUSDTExact(orderValue);
        const isCapped = rawOwnerFeeInETH > BigInt(feeCap);
        
        // Show order confirmation with fees - FIXED: use precise values
        const confirm = await Swal.fire({
            title: 'Confirm Sell Order',
            html: `
                <div style="text-align: left;">
                    <p><strong>Selling:</strong> ${preciseCoins} tokens @ ${precisePrice} USDT each</p>
                    <p><strong>Total Value:</strong> ${preciseTotalValue} USDT</p>
                    <p><strong>Current Rate:</strong> 1 ETH = ${(Number(usdtPerEth)/1e6).toFixed(2)} USDT</p>
                    <hr>
                    <p><strong>Fees:</strong></p>
                    ${isCapped ? `
                        <p>• <span style="text-decoration: line-through;">Original Fee: ${formatUSDTExact(rawOwnerFeeInUSDT)} USDT (${web3.utils.fromWei(rawOwnerFeeInETH.toString(), 'ether')} ETH)</span></p>
                        <p>• <strong style="color: #FFC107;">Capped Fee:</strong> ${formatUSDTExact(feeCapInUSDT)} USDT (${web3.utils.fromWei(feeCap.toString(), 'ether')} ETH)</p>
                    ` : `
                        <p>• Owner Fee: ${formatUSDTExact(rawOwnerFeeInUSDT)} USDT (${web3.utils.fromWei(rawOwnerFeeInETH.toString(), 'ether')} ETH)</p>
                    `}
                    <p>• Network Fee: ~${web3.utils.fromWei(networkFee.toString(), 'ether')} ETH</p>
                    <p>• Fee Buffer: 10%</p>
                    <p><strong>Total Required:</strong> ${web3.utils.fromWei(totalFees.toString(), 'ether')} ETH</p>
                    ${isCapped ? `<p><small>Note: Fee has been capped at ${web3.utils.fromWei(feeCap.toString(), 'ether')} ETH</small></p>` : ''}
                </div>
            `,
            showCancelButton: true,
            confirmButtonText: 'Confirm Order',
            confirmButtonColor: 'red',
            allowOutsideClick: false
        });
        
        if (!confirm.isConfirmed) return;
        
        // Execute order placement
        processingSwal = Swal.fire({
            title: 'Processing Order...',
            allowOutsideClick: false,
            didOpen: () => Swal.showLoading()
        });
        
        const tx = await placeSellContract.methods
            .placeSellOrderUSDT(priceInUSDTUnits.toString(), tokenAmount.toString())
            .send({
                from: window.appState.userAccount,
                value: ownerFeeInETHWithBuffer.toString(),
                gas: gasWithBuffer.toString()
            });
            
        await processingSwal.close();
        
        // Show success
        await Swal.fire({
            icon: 'success',
            title: 'Order Placed!',
            html: `Transaction: <a href="https://etherscan.io/tx/${tx.transactionHash}" target="_blank">View on Etherscan</a>`,
            confirmButtonColor: 'red'
        });
        
        // Clear form
        document.getElementById('sellUSDTPriceInput').value = '';
        document.getElementById('sellCoinUSDTInput').value = '';
        
    } catch (error) {
        if (processingSwal) await processingSwal.close();
        
        let errorMsg = error.message;
        if (error.code === 4001) {
            errorMsg = "You rejected the transaction";
        } else if (error.message.includes("Approval was cancelled")) {
            errorMsg = "Token approval was cancelled";
        } else if (error.message.includes("Insufficient")) {
            errorMsg = error.message;
        } else if (error.data?.message) {
            errorMsg = error.data.message;
        }
        
        await Swal.fire({
            icon: 'error',
            title: 'Error',
            text: errorMsg,
            confirmButtonColor: 'red'
        });
    }
}
// Attach event listener
document.getElementById('placeUSDTOrderButton2').addEventListener('click', placeSellOrder); </script><!-- end place sell order USDT-->
                    </div>
                  </div>
                </div>
                <div class="custom-expanded u-align-center u-container-align-center u-container-align-center-lg u-container-align-center-xl u-container-style u-custom-color-5 u-expanded-width u-group u-radius u-shape-round u-group-4">
                  <div class="u-container-layout u-container-layout-6">
                    <h4 class="u-text u-text-default u-text-4">Sell Orders&nbsp;USDT</h4>
                    <div class="custom-expanded u-clearfix u-custom-html u-expanded-width u-custom-html-4"><!-- Display Sell Orders USDT with Price Validation -->
                      <style> /* Container styling */
  #usdtSellOrdersContainer {
    margin-top: 20px;
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    background-color: #121212;
    border-radius: 8px;
    padding: 2px;
  }
  /* Table styling */
  #usdtSellOrdersTable {
    width: 100%;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    color: #e0e0e0;
  }
  /* Table header styling */
  #usdtSellOrdersTable th {
    background-color: #1e1e1e;
    color: #ffffff;
    padding: 12px 10px;
    text-align: left;
    position: sticky;
    top: 0;
    font-weight: 600;
    border-bottom: 1px solid #333;
  }
  /* Table cell styling */
  #usdtSellOrdersTable td {
    padding: 10px;
    border-bottom: 1px solid #333;
    word-break: break-word;
  }
  /* Zebra striping */
  #usdtSellOrdersTable tr:nth-child(odd) {
    background-color: #1a1a1a;
  }
  #usdtSellOrdersTable tr:nth-child(even) {
    background-color: #121212;
  }
  /* Hover effect */
  #usdtSellOrdersTable tr:hover {
    background-color: #2a2a2a !important;
  }
  /* Button styling */
  .remove-order-btn,
  .update-order-btn {
    min-width: 70px;
    width: auto;
    padding: 6px 8px;
    border: none;
    border-radius: 4px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 500;
    margin-right: 5px;
    text-align: center;
    display: inline-block;
    box-sizing: border-box;
    line-height: 1.2;
    white-space: nowrap;
  }
  .remove-order-btn:hover {
    background-color: #FFA000;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  .update-order-btn:hover {
    background-color: #218838;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  .remove-order-btn {
    background-color: #FFC107;
    color: #000;
  }
  .update-order-btn {
    background-color: #28a745;
    color: white;
  }
  /* Order ID styling */
  .order-id {
    font-family: 'Courier New', monospace;
    color: #9e9e9e;
    font-size: 0.9em;
  }
  /* Column width adjustments */
  #usdtSellOrdersTable th:nth-child(1),
  #usdtSellOrdersTable td:nth-child(1) {
    width: 15%;
  }
  #usdtSellOrdersTable th:nth-child(2),
  #usdtSellOrdersTable td:nth-child(2) {
    width: 25%;
  }
  #usdtSellOrdersTable th:nth-child(3),
  #usdtSellOrdersTable td:nth-child(3) {
    width: 25%;
  }
  #usdtSellOrdersTable th:nth-child(4),
  #usdtSellOrdersTable td:nth-child(4) {
    width: 35%;
    min-width: 150px;
  }
  /* Mobile adjustments */
  @media (max-width: 768px) {
    .remove-order-btn,
    .update-order-btn {
      min-width: 60px;
      padding: 5px 6px;
      font-size: 13px;
      margin-right: 4px;
    }
    #usdtSellOrdersTable th:nth-child(1),
    #usdtSellOrdersTable td:nth-child(1) {
      width: 20%;
    }
    #usdtSellOrdersTable th:nth-child(4),
    #usdtSellOrdersTable td:nth-child(4) {
      width: 30%;
      min-width: 120px;
    }
  }
  @media (max-width: 480px) {
    .remove-order-btn,
    .update-order-btn {
      min-width: 55px;
      padding: 4px 5px;
      font-size: 12px;
    }
    .remove-order-btn {
      min-width: 50px;
      padding: 4px;
      font-size: 11px;
    }
    .update-order-btn {
      min-width: 50px;
      padding: 4px;
      font-size: 11px;
    }
  } </style>
                      <div id="usdtSellOrdersContainer">
                        <table id="usdtSellOrdersTable">
                          <thead>
                            <tr>
                              <th>ID</th>
                              <th>Price</th>
                              <th>Amount</th>
                              <th>Actions</th>
                            </tr>
                          </thead>
                          <tbody id="usdtSellOrdersList"><!-- Orders will be inserted here dynamically --></tbody>
                        </table>
                      </div>
                      <script> // USDT Sell Orders Display and Management
const USDTSellOrdersManager = (function() {
  // Contract configuration
  const config = {
    sellOrdersContractAddress: '0x5E2aDEb82C79341C20fD94aC497f57ee5Ba50725',
    centralContractAddress: '0xca1D91233233f2cC0B0dC61a7c268dF5e223D081',
    usdtContractAddress: '0xdAC17F958D2ee523a2206206994597C13D831ec7',
    
    sellOrdersContractABI: [
      {
        "inputs": [],
        "name": "getSellOrdersUSDT",
        "outputs": [
          {
            "components": [
              { "internalType": "uint256", "name": "orderID", "type": "uint256" },
              { "internalType": "address payable", "name": "user", "type": "address" },
              { "internalType": "uint256", "name": "price", "type": "uint256" },
              { "internalType": "uint256", "name": "amount", "type": "uint256" },
              { "internalType": "uint256", "name": "fulfilledAmount", "type": "uint256" },
              { "internalType": "enum SharedStructs.AssetType", "name": "assetType", "type": "uint8" },
              { "internalType": "enum SharedStructs.PaymentMethod", "name": "priceCurrency", "type": "uint8" },
              { "internalType": "bool", "name": "authorizedBuyersOnly", "type": "bool" }
            ],
            "internalType": "struct SharedStructs.Order[]",
            "name": "",
            "type": "tuple[]"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [{"internalType": "uint256", "name": "orderID", "type": "uint256"}],
        "name": "RemoveOrder",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {"internalType": "uint256", "name": "orderID", "type": "uint256"},
          {"internalType": "uint256", "name": "newPrice", "type": "uint256"}
        ],
        "name": "changeSellOrderPriceUSDT",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      }
    ],
    
    usdtContractABI: [
      {
        "constant": false,
        "inputs": [
            {"name": "_spender", "type": "address"},
            {"name": "_value", "type": "uint256"}
        ],
        "name": "approve",
        "outputs": [],
        "type": "function"
    },
      {
        "constant": true,
        "inputs": [
            {"name": "_owner", "type": "address"},
            {"name": "_spender", "type": "address"}
        ],
        "name": "allowance",
        "outputs": [
            {"name": "", "type": "uint256"}
        ],
        "type": "function"
    }
    ],
    
    // Updated central contract ABI with LMEprice
    centralContractABI: [
      {
        "inputs": [],
        "name": "feePercentage",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "feeCap",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "LMEprice",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
      }
    ]
  };
  
  let processingSwal = null;
  
  // Helper function to parse decimal input with precise BigInt conversion
  function parseDecimalInput(input, decimals) {
    if (!input || typeof input !== 'string') {
      throw new Error("Invalid input: must be a non-empty string");
    }
    
    input = input.trim();
    let [integerPart, fractionalPart = ''] = input.split('.');
    
    // Pad the fractional part with zeros to the desired number of decimals
    fractionalPart = fractionalPart.padEnd(decimals, '0');
    fractionalPart = fractionalPart.substring(0, decimals);
    const fullNumberString = integerPart + fractionalPart;
    const significantNumberString = fullNumberString.replace(/^0+/, '') || '0';
    
    return BigInt(significantNumberString);
  }
  
  // Format USDT price (6 decimals)
  function formatUSDTPrice(usdtUnits) {
    const usdtNum = Number(usdtUnits);
    return (usdtNum / 1e6).toLocaleString('en-US', { 
      minimumFractionDigits: 2, 
      maximumFractionDigits: 6 
    });
  }
  
  // Format token amount (3 decimals)
  function formatTokenAmount(tokenAmount) {
    const tokenNum = Number(tokenAmount);
    return (tokenNum / 1000).toLocaleString('en-US', { 
      minimumFractionDigits: 1, 
      maximumFractionDigits: 3 
    });
  }
  
  // Remove order function
  async function removeSellOrder(orderId) {
    if (!window.appState?.isConnected) {
        await Swal.fire('Error', 'Please connect your wallet first', 'error');
        return;
    }
    
    try {
        const confirmResult = await Swal.fire({
            title: 'Confirm Removal',
            text: 'Are you sure you want to remove this sell order?',
            icon: 'warning',
            showCancelButton: true,
            confirmButtonColor: '#FFC107',
            confirmButtonText: 'Yes, remove it!',
            cancelButtonText: 'Cancel'
        });
        
        if (!confirmResult.isConfirmed) return;
        
        processingSwal = Swal.fire({
            title: 'Removing Sell Order...',
            allowOutsideClick: false,
            didOpen: () => Swal.showLoading()
        });
        
        const contract = new window.appState.web3.eth.Contract(
            config.sellOrdersContractABI,
            config.sellOrdersContractAddress
        );
        
        const tx = await contract.methods
            .RemoveOrder(orderId)
            .send({ from: window.appState.userAccount });
        
        await processingSwal.close();
        
        await Swal.fire({
            icon: 'success',
            title: 'Order Removed!',
            html: `Transaction: <small>${tx.transactionHash}</small>`,
            confirmButtonColor: '#FFC107'
        });
        
        refreshUSDTSellOrders();
    } catch (error) {
        if (processingSwal) await processingSwal.close();
        
        let errorMsg = error.message;
        if (error.code === 4001) errorMsg = "You rejected the transaction";
        else if (error.receipt?.status === false) errorMsg = "Transaction failed on-chain";
        else if (error.message.includes("Only order owner can remove")) {
            errorMsg = "You can only remove your own orders";
        }
        
        await Swal.fire({
            icon: 'error',
            title: 'Removal Failed',
            text: errorMsg,
            confirmButtonColor: '#FFC107'
        });
    }
  }
  
  // Update USDT order price with price validation
  async function updateUSDTSellOrderPrice(orderId, currentPriceUSDT) {
    if (!window.appState?.isConnected) {
        await Swal.fire('Error', 'Please connect your wallet first', 'error');
        return;
    }
    
    try {
        // Get current LME price first
        const centralContract = new window.appState.web3.eth.Contract(
            config.centralContractABI,
            config.centralContractAddress
        );
        const LMEprice = await centralContract.methods.LMEprice().call();
        const lmePriceUSDT = Number(LMEprice) / 1e6;
        
        const { value: newPriceUSDT } = await Swal.fire({
            title: 'Update Order Price',
            html: `
                <div>
                    <p>Current Price: <strong>${currentPriceUSDT} USDT</strong></p>
                    <p>Minimum Allowed Price: <strong>${lmePriceUSDT.toFixed(6)} USDT</strong></p>
                    <input 
                        id="newPriceInput" 
                        type="text" 
                        class="swal2-input" 
                        placeholder="Enter new price (USDT)"
                        pattern="[0-9.]+"
                    >
                </div>
            `,
            focusConfirm: false,
            showCancelButton: true,
            confirmButtonText: 'Update Price',
            cancelButtonText: 'Cancel',
            preConfirm: () => {
                const input = Swal.getPopup().querySelector('#newPriceInput');
                const value = input.value.trim();
                
                if (!value || value === '') {
                    Swal.showValidationMessage('Please enter a price');
                    return false;
                }
                
                // Validate decimal format
                if (!/^\d+(\.\d+)?$/.test(value)) {
                    Swal.showValidationMessage('Please enter a valid price (numbers and decimal only)');
                    return false;
                }
                
                // Validate decimal places
                const decimalPart = value.split('.')[1];
                if (decimalPart && decimalPart.length > 6) {
                    Swal.showValidationMessage('Maximum 6 decimal places allowed for USDT');
                    return false;
                }
                
                // Validate minimum price
                const priceValue = parseFloat(value);
                if (isNaN(priceValue)) {
                    Swal.showValidationMessage('Please enter a valid number');
                    return false;
                }
                
                if (priceValue < lmePriceUSDT) {
                    Swal.showValidationMessage(`Price must be ≥ ${lmePriceUSDT.toFixed(6)} USDT`);
                    return false;
                }
                
                return value;
            }
        });
        
        if (!newPriceUSDT) return;
        
        // Initialize contracts
        const sellOrdersContract = new window.appState.web3.eth.Contract(
            config.sellOrdersContractABI,
            config.sellOrdersContractAddress
        );
        
        // Convert price to USDT units using precise decimal parsing (6 decimals)
        const newPriceInUSDTUnits = parseDecimalInput(newPriceUSDT, 6);
        
        processingSwal = Swal.fire({
            title: 'Updating Sell Order...',
            allowOutsideClick: false,
            didOpen: () => Swal.showLoading()
        });
        
        // Execute the price update
        const tx = await sellOrdersContract.methods
            .changeSellOrderPriceUSDT(orderId, newPriceInUSDTUnits.toString())
            .send({ from: window.appState.userAccount });
        
        await processingSwal.close();
        
        await Swal.fire({
            icon: 'success',
            title: 'Price Updated!',
            html: `Transaction: <small>${tx.transactionHash}</small>`,
            confirmButtonColor: '#28a745'
        });
        
        refreshUSDTSellOrders();
        
    } catch (error) {
        if (processingSwal) await processingSwal.close();
        
        let errorMsg = error.message;
        if (error.code === 4001) errorMsg = "You rejected the transaction";
        else if (error.receipt?.status === false) errorMsg = "Transaction failed on-chain";
        else if (error.message.includes("Only the owner can change the price")) {
            errorMsg = "You can only update your own orders";
        } else if (error.message.includes("Price must be ≥")) {
            errorMsg = error.message;
        }
        
        await Swal.fire({
            icon: 'error',
            title: 'Update Failed',
            text: errorMsg,
            confirmButtonColor: '#28a745'
        });
    }
  }
  
  // Render USDT sell orders
  async function renderUSDTSellOrders(orders) {
    const ordersList = document.getElementById('usdtSellOrdersList');
    
    if (!orders || orders.length === 0) {
        ordersList.innerHTML = '<tr><td colspan="4" style="text-align: center;">No USDT sell orders available</td></tr>';
        return;
    }
    
    const fragment = document.createDocumentFragment();
    
    for (const order of orders) {
        const row = document.createElement('tr');
        
        // Check if this order belongs to the current user
        const isUserOrder = window.appState.userAccount && 
                           order.user.toLowerCase() === window.appState.userAccount.toLowerCase();
        
        const currentPriceUSDT = formatUSDTPrice(order.price);
        
        row.innerHTML = `
            <td class="order-id">${order.orderID}</td>
            <td>${currentPriceUSDT} USDT</td>
            <td>${formatTokenAmount(order.amount)}</td>
            <td class="order-actions"></td>
        `;
        
        if (isUserOrder) {
            const actionsCell = row.querySelector('.order-actions');
            
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-order-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.onclick = (e) => {
                e.preventDefault();
                removeSellOrder(order.orderID);
            };
            
            const updateBtn = document.createElement('button');
            updateBtn.className = 'update-order-btn';
            updateBtn.textContent = 'Update';
            updateBtn.onclick = (e) => {
                e.preventDefault();
                updateUSDTSellOrderPrice(order.orderID, currentPriceUSDT);
            };
            
            actionsCell.appendChild(removeBtn);
            actionsCell.appendChild(updateBtn);
        }
        
        fragment.appendChild(row);
    }
    
    ordersList.innerHTML = '';
    ordersList.appendChild(fragment);
  }
  
  // Fetch and refresh USDT sell orders
  async function refreshUSDTSellOrders() {
    if (!window.appState?.web3) {
      document.getElementById('usdtSellOrdersList').innerHTML = 
        '<tr><td colspan="4" style="text-align: center;">Wallet not connected</td></tr>';
      return;
    }
    
    try {
      const contract = new window.appState.web3.eth.Contract(
        config.sellOrdersContractABI,
        config.sellOrdersContractAddress
      );
      
      const orders = await contract.methods.getSellOrdersUSDT().call();
      await renderUSDTSellOrders(orders);
    } catch (error) {
      console.error('Error fetching USDT sell orders:', error);
      document.getElementById('usdtSellOrdersList').innerHTML = 
        '<tr><td colspan="4" style="text-align: center;">Error loading orders</td></tr>';
    }
  }
  
  // Initialize polling
  function startPolling() {
    refreshUSDTSellOrders();
    return setInterval(refreshUSDTSellOrders, 5000);
  }
  
  let pollInterval = null;
  
  return {
    refreshUSDTSellOrders,
    removeSellOrder,
    updateUSDTSellOrderPrice,
    startPolling
  };
})();
// Initialize when wallet is ready
function initUSDTSellOrders() {
  if (window.appState?.isConnected) {
    USDTSellOrdersManager.refreshUSDTSellOrders();
    if (!window.usdtSellOrdersPollStarted) {
      window.usdtSellOrdersPollStarted = true;
      USDTSellOrdersManager.startPolling();
    }
  }
}
// Set up event listeners
window.addEventListener('appState:connectionChanged', initUSDTSellOrders);
document.addEventListener('DOMContentLoaded', function() {
  if (window.appState?.isConnected) {
    initUSDTSellOrders();
  }
  window.addEventListener('appState:connectionChanged', initUSDTSellOrders);
});
// Make refresh function available globally
window.refreshUSDTSellOrders = USDTSellOrdersManager.refreshUSDTSellOrders; </script><!-- end display Sell Orders USDT with Price Validation -->
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    
    
    
    
    
    
    
    
    
    
    
    <footer class="u-align-center u-black u-clearfix u-container-align-center u-footer" id="sec-8726"><div class="u-clearfix u-sheet u-sheet-1">
        <p class="u-align-center u-small-text u-text u-text-variant u-text-1"> © All Rights Reserved, Decentralized Application , 2025 , Destrier LLC, 1942 Broadway St. , STE 314C, Boulder, CO 80302, US<br>
          <a href="#" class="u-active-none u-border-none u-btn u-button-link u-button-style u-hover-none u-none u-text-body-alt-color u-btn-1">www.nickelium.com</a>
        </p>
      </div></footer><section class="u-align-center u-clearfix u-cookies-consent u-grey-80 u-cookies-consent" id="sec-b719">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="u-clearfix u-expanded-width u-layout-wrap u-layout-wrap-1">
          <div class="u-gutter-0 u-layout">
            <div class="u-layout-row">
              <div class="u-container-style u-layout-cell u-left-cell u-size-43-md u-size-43-sm u-size-43-xs u-size-46-lg u-size-46-xl u-layout-cell-1">
                <div class="u-container-layout u-valign-middle u-container-layout-1">
                  <h3 class="u-text u-text-default u-text-1">Cookies &amp; Privacy</h3>
                  <p class="u-text u-text-default u-text-2">This website uses cookies to ensure you get the best experience on our website.</p>
                </div>
              </div>
              <div class="u-align-left u-container-style u-layout-cell u-right-cell u-size-14-lg u-size-14-xl u-size-17-md u-size-17-sm u-size-17-xs u-layout-cell-2">
                <div class="u-container-layout u-valign-middle-lg u-valign-middle-md u-valign-middle-xl u-valign-top-sm u-valign-top-xs u-container-layout-2">
                  <a href="###" class="u-btn u-button-confirm u-button-style u-palette-1-base u-btn-1">Confirm</a>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    <style> .u-cookies-consent {
  background-image: none;
}

.u-cookies-consent .u-sheet-1 {
  min-height: 212px;
}

.u-cookies-consent .u-layout-wrap-1 {
  margin-top: 30px;
  margin-bottom: 30px;
}

.u-cookies-consent .u-layout-cell-1 {
  min-height: 152px;
}

.u-cookies-consent .u-container-layout-1 {
  padding: 30px 60px;
}

.u-cookies-consent .u-text-1 {
  margin-top: 0;
  margin-right: 20px;
  margin-bottom: 0;
}

.u-cookies-consent .u-text-2 {
  margin: 8px 20px 0 0;
}

.u-cookies-consent .u-layout-cell-2 {
  min-height: 152px;
}

.u-cookies-consent .u-container-layout-2 {
  padding: 30px;
}

.u-cookies-consent .u-btn-1 {
  margin: 0 auto 0 0;
}

@media (max-width: 1199px) {
  .u-cookies-consent .u-sheet-1 {
    min-height: 131px;
  }

  .u-cookies-consent .u-layout-cell-1 {
    min-height: 125px;
  }

  .u-cookies-consent .u-text-1 {
    margin-right: 0;
  }

  .u-cookies-consent .u-text-2 {
    margin-right: 0;
  }

  .u-cookies-consent .u-layout-cell-2 {
    min-height: 125px;
  }
}

@media (max-width: 991px) {
  .u-cookies-consent .u-sheet-1 {
    min-height: 106px;
  }

  .u-cookies-consent .u-layout-cell-1 {
    min-height: 100px;
  }

  .u-cookies-consent .u-container-layout-1 {
    padding-left: 30px;
    padding-right: 30px;
  }

  .u-cookies-consent .u-layout-cell-2 {
    min-height: 100px;
  }
}

@media (max-width: 767px) {
  .u-cookies-consent .u-sheet-1 {
    min-height: 225px;
  }

  .u-cookies-consent .u-layout-cell-1 {
    min-height: 154px;
  }

  .u-cookies-consent .u-container-layout-1 {
    padding-left: 10px;
    padding-right: 10px;
    padding-bottom: 20px;
  }

  .u-cookies-consent .u-layout-cell-2 {
    min-height: 65px;
  }

  .u-cookies-consent .u-container-layout-2 {
    padding: 10px;
  }
}

@media (max-width: 575px) {
  .u-cookies-consent .u-sheet-1 {
    min-height: 121px;
  }

  .u-cookies-consent .u-layout-cell-1 {
    min-height: 100px;
  }

  .u-cookies-consent .u-layout-cell-2 {
    min-height: 15px;
  }
}</style></section>
  
</body></html>