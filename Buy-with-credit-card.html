<!DOCTYPE html>
<html style="font-size: 16px;" lang="en"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <meta name="keywords" content="">
    <meta name="description" content="">
    <title>Buy with credit card</title>
    <link rel="stylesheet" href="nicepage.css" media="screen">
<link rel="stylesheet" href="Buy-with-credit-card.css" media="screen">
    <script class="u-script" type="text/javascript" src="jquery.js" defer=""></script>
    <script class="u-script" type="text/javascript" src="nicepage.js" defer=""></script>
    <meta name="generator" content="Nicepage 7.14.0, nicepage.com">
    
    
    
    
    
    
    
    
    
    
    
    <link id="u-page-google-font" rel="stylesheet" href="https://fonts.googleapis.com/css2?display=swap&amp;family=Roboto:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&amp;family=Open+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;1,300;1,400;1,500;1,600;1,700;1,800">
    <script type="application/ld+json">{
		"@context": "http://schema.org",
		"@type": "Organization",
		"name": "Site Main Ethereum",
		"logo": "images/logo-nickelium.svg"
}</script>
    <meta name="theme-color" content="#478ac9">
    <meta property="og:title" content="Buy with credit card">
    <meta property="og:description" content="">
    <meta property="og:type" content="website">
  <meta name="robots" content="noindex, nofollow"><meta name="robots" content="noindex, nofollow"><meta data-intl-tel-input-cdn-path="intlTelInput/"></head>
  <body data-path-to-root="./" data-include-products="false" class="u-body u-clearfix u-custom-color-4 u-xl-mode" data-lang="en"><header class="u-clearfix u-custom-color-4 u-header" id="sec-6bd7" data-animation-name="" data-animation-duration="0" data-animation-delay="0" data-animation-direction=""><div class="u-clearfix u-sheet u-sheet-1">
        <a href="./" data-page-id="132619714" class="u-image u-logo u-image-1" data-image-width="150" data-image-height="47" title="Home">
          <img src="images/logo-nickelium.svg" class="u-logo-image u-logo-image-1" title="Home">
        </a>
        <nav class="u-dropdown-icon u-menu u-menu-dropdown u-offcanvas u-menu-1" role="navigation" aria-label="Menu navigation">
          <div class="menu-collapse u-custom-font u-font-roboto" style="font-size: 1rem; letter-spacing: 0px;">
            <a class="u-button-style u-custom-color u-custom-left-right-menu-spacing u-custom-padding-bottom u-custom-top-bottom-menu-spacing u-hamburger-link u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base u-hamburger-link-1" href="#" tabindex="-1" aria-label="Open menu" aria-controls="f706">
              <svg class="u-svg-link" viewBox="0 0 24 24"><use xlink:href="#menu-hamburger"></use></svg>
              <svg class="u-svg-content" version="1.1" id="menu-hamburger" viewBox="0 0 16 16" x="0px" y="0px" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg"><g><rect y="1" width="16" height="2"></rect><rect y="7" width="16" height="2"></rect><rect y="13" width="16" height="2"></rect>
</g></svg>
            </a>
          </div>
          <div class="u-custom-menu u-nav-container">
            <ul class="u-custom-font u-font-roboto u-nav u-unstyled u-nav-1" role="menubar"><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="./" style="padding: 10px 20px;">Home</a>
</li><li role="none" class="u-nav-item"><a tabindex="-1" role="menuitem" class="u-button-style u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" aria-haspopup="true" aria-current="page" style="padding: 10px 20px;">Menu</a><div class="u-nav-popup"><ul role="menu" class="u-custom-font u-font-roboto u-h-spacing-20 u-nav u-unstyled u-v-spacing-10 u-nav-2" aria-label="Menu menu"><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-custom-color-4 u-nav-link" href="Nickelium-in-Ether.html">Nickelium in Ether</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-custom-color-4 u-nav-link" href="Nickelium-in-USDT.html">Nickelium in USDT</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-custom-color-4 u-nav-link" href="Nickelium-in-USDC.html">Nickelium in USDC</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-custom-color-4 u-nav-link" href="Buy-with-credit-card.html" target="_blank">Buy with credit card</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-custom-color-4 u-nav-link" href="Transfer-Nickelium.html" target="_blank">Transfer Nickelium</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-custom-color-4 u-nav-link" href="Nickelium-Transfers-History.html" target="_blank">My transfers History</a>
</li></ul>
</div>
</li></ul>
          </div>
          <div class="u-custom-menu u-nav-container-collapse" id="f706" role="region" aria-label="Menu panel">
            <div class="u-container-style u-custom-color-4 u-inner-container-layout u-opacity u-opacity-95 u-sidenav">
              <div class="u-inner-container-layout u-sidenav-overflow">
                <div class="u-menu-close" tabindex="-1" aria-label="Close menu"></div>
                <ul class="u-align-center u-nav u-popupmenu-items u-unstyled u-nav-3" role="menubar"><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="./">Home</a>
</li><li role="none" class="u-nav-item"><a tabindex="-1" role="menuitem" class="u-button-style u-nav-link" aria-haspopup="true" aria-current="page">Menu</a><div class="u-nav-popup"><ul role="menu" class="u-custom-font u-font-roboto u-h-spacing-20 u-nav u-unstyled u-v-spacing-10 u-nav-4" aria-label="Menu menu"><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="Nickelium-in-Ether.html">Nickelium in Ether</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="Nickelium-in-USDT.html">Nickelium in USDT</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="Nickelium-in-USDC.html">Nickelium in USDC</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="Buy-with-credit-card.html" target="_blank">Buy with credit card</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="Transfer-Nickelium.html" target="_blank">Transfer Nickelium</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="Nickelium-Transfers-History.html" target="_blank">My transfers History</a>
</li></ul>
</div>
</li></ul>
              </div>
            </div>
            <div class="u-menu-overlay u-opacity u-opacity-70"></div>
          </div>
        </nav>
        <div class="custom-expanded u-clearfix u-custom-html u-preserve-proportions u-custom-html-1">
          <div>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title></title>
            <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
            <style> #connectButton {
    background: linear-gradient(to bottom right, #6211f0, #8c2dda);
    color: white; /* Ensure text is visible */
    padding: 10px 20px; /* Adjust padding as needed */
    border-radius: 8px; /* Match other rounded elements */
    border: none; /* Remove any default button borders */
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center; /* Center content horizontally */
    font-size: 1.1em;
    font-weight: bold;
    transition: background-color 0.2s ease;
}

#connectButton:hover {
    background: linear-gradient(to bottom right, #8c2dda, #6211f0);
}

        /* General SweetAlert2 styling for custom buttons */
        .swal2-html-container { /* This is the div SweetAlert2 uses for 'html' content */
            max-height: 300px ;  /* Adjust as needed */
            overflow-y: auto ;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center items horizontally within the container */
        }
        .swal2-html-container button {
            display: flex; /* Make buttons flex containers for icon and text */
            align-items: center; /* Vertically align icon and text */
            justify-content: flex-start; /* Align content to the start (left) */
            margin: 8px auto; /* Add vertical margin and center horizontally */
            width: 80%; /* Make buttons take up most of the width */
            max-width: 280px; /* Max width for larger screens */
            padding: 12px 20px; /* Add padding */
            border-radius: 8px; /* Slightly rounded corners */
            font-size: 1.1em; /* Larger font size */
            font-weight: bold;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: left; /* Ensure text aligns left within the button */
        }
        .swal2-html-container button img {
            margin-right: 15px; /* Space between icon and text */
            width: 38px; /* Slightly larger icons */
            height: 38px;
        }
        /* Specific button colors */
        #btnMetamask { background-color: #f6851b; }
        #btnCoinbase { background-color: #0052FF; }
        #btnTrust { background-color: #3375BB; }
        /* REMOVED: #btnBinance { background-color: #F0B90B; } */
        /* Hover effects */
        #btnMetamask:hover { background-color: #e07a10; }
        #btnCoinbase:hover { background-color: #0042d0; }
        #btnTrust:hover { background-color: #2a63a0; }
        /* REMOVED: #btnBinance:hover { background-color: #d8a000; } */
        /* Styles for the Cancel button if you choose to include it as part of the HTML */
        .swal2-styled.swal2-cancel {
            background-color: #6c757d !important; /* Default grey for cancel */
            color: white !important;
            margin-top: 15px; /* Add more space above cancel button */
            justify-content: center !important; /* Center the text for cancel button */
        }
        .swal2-styled.swal2-cancel:hover {
            background-color: #5a6268 !important;
        } </style>
            <button id="connectButton">
              <style="width: 20px;="" height:="" margin-right:="" 10px;"=""> Connect </style="width:>
            </button>
            <div id="walletInfo"></div>
            <div id="qrCodeContainer" style="display:none; text-align: center; margin-top: 20px;">
              <h3>Scan to open this DApp in your mobile wallet:</h3>
              <div id="qrcode" style="margin-top: 20px;"></div>
              <p style="margin-top: 20px;">After scanning, please manually click "Connect Wallet" inside your mobile app's browser to connect.</p>
            </div>
            <script> // Define appUtils before any other code that might use it
    window.appUtils = {
        deepEqual: function(a, b) {
            try {
                return JSON.stringify(this.convertBigIntToString(a)) ===
                                     JSON.stringify(this.convertBigIntToString(b));
            } catch (e) {
                console.error("Comparison error:", e);
                return false;
            }
        },
        convertBigIntToString: function(obj) {
            if (typeof obj === 'bigint') return obj.toString();
            if (Array.isArray(obj)) return obj.map(this.convertBigIntToString.bind(this));
            if (obj && typeof obj === 'object') {
                return Object.fromEntries(
                    Object.entries(obj).map(([k, v]) => [k, this.convertBigIntToString(v)])
                );
            }
            return obj;
        },
        formatEth: function(wei) {
            if (!window.appState?.web3) return "0.00";
            try {
                return parseFloat(window.appState.web3.utils.fromWei(wei.toString(), 'ether'))
                    .toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 4 });
            } catch (e) {
                console.error("Format ETH error:", e);
                return "0.00";
            }
        },
        formatToken: function(amount) {
            try {
                return (Number(amount) / 1000).toLocaleString('en-US', {
                    minimumFractionDigits: 1,
                    maximumFractionDigits: 3
                });
            } catch (e) {
                console.error("Format token error:", e);
                return "0.0";
            }
        }
    };
    class WalletManager {
        static state = {
            web3: null,
            userAccount: null,
            isConnected: false,
            contractAddress: '0x5E2aDEb82C79341C20fD94aC497f57ee5Ba50725',
            isMobile: false,
            qrCodeShown: false
        };
        static init() {
            if (typeof Web3 === 'undefined' || typeof Swal === 'undefined' || typeof QRCode === 'undefined') {
                setTimeout(() => this.init(), 200); // Retry initialization
                return;
            }
            this.state.isMobile = this.detectMobile();
            if (document.readyState === 'complete') {
                this.initialize();
            } else {
                document.addEventListener('DOMContentLoaded', () => this.initialize());
            }
        }
        static initialize() {
            this.setupEventListeners();
            // Attempt to connect immediately if a wallet is present (e.g., in DApp browser)
            if (this.hasWalletInCurrentBrowser()) {
                this.checkPersistedConnection();
            } else {
                this.updateUI();
            }
            window.appState = {
                get web3() { return WalletManager.state.web3; },
                get userAccount() { return WalletManager.state.userAccount; },
                get isConnected() { return WalletManager.state.isConnected; },
                get contractAddress() { return WalletManager.state.contractAddress; }
            };
            window.addEventListener('appState:connectionChanged', (e) => {
                if (e.detail?.ready) {
                    this.handleConnectionReady();
                }
            });
        }
        static detectMobile() {
            const toMatch = [
                /Android/i, /webOS/i, /iPhone/i, /iPad/i, /iPod/i, /BlackBerry/i, /Windows Phone/i
            ];
            return toMatch.some((toMatchItem) => navigator.userAgent.match(toMatchItem));
        }
        static async checkPersistedConnection() {
            if (!this.hasWalletInCurrentBrowser()) {
                return false;
            }
            try {
                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                if (accounts.length > 0) {
                    await this.handleSuccessfulConnection(accounts[0]);
                    return true;
                } else {
                    if (localStorage.getItem('walletConnected') === 'true') {
                        return await this.connectInjectedWallet();
                    }
                }
            } catch (error) {
                console.error(`Auto-reconnect failed: ${error.message}`);
            }
            this.updateUI();
            return false;
        }
        static hasWalletInCurrentBrowser() {
            return typeof window.ethereum !== 'undefined';
        }
        static async connectInjectedWallet() {
            try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (accounts.length > 0) {
                    await this.handleSuccessfulConnection(accounts[0]);
                    return true;
                }
            } catch (error) {
                Swal.fire({
                    title: 'Connection Error',
                    text: error.message,
                    icon: 'error'
                });
            }
            return false;
        }
        static connectMobileWalletViaDeeplink(walletType = 'metamask') {
            const currentUrl = window.location.href;
            const dappUrlEncoded = encodeURIComponent(currentUrl);
            let deepLinkUrl = '';
            let walletName = '';
            let troubleshootingText = '';
            switch (walletType) {
                case 'metamask':
                    deepLinkUrl = `https://metamask.app.link/dapp/${currentUrl}`;
                    walletName = 'MetaMask';
                    troubleshootingText = 'You may need to manually navigate to this DApp URL within MetaMask\'s internal browser.';
                    break;
                case 'coinbase':
                    deepLinkUrl = `https://go.cb-w.com/dapp?cb_url=${dappUrlEncoded}`;
                    walletName = 'Coinbase Wallet';
                    troubleshootingText = `<b>IMPORTANT:</b> If the DApp page doesn't open directly (e.g., if it opens to the wallet's dashboard), please manually navigate to this URL: <br><br><code>${window.location.href}</code><br><br> within Coinbase Wallet's DApp browser.`;
                    break;
                /* REMOVED BINANCE CASE
                case 'binance':
                    deepLinkUrl = `binance://dapp?url=${dappUrlEncoded}`;
                    walletName = 'Binance Wallet';
                    troubleshootingText = 'You may need to manually navigate to this DApp URL within Binance Wallet\'s internal browser. Please verify official Binance deep link documentation if issues persist.';
                    break;
                */
                case 'kraken':
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                    deepLinkUrl = isIOS
                        ? `kraken://open?url=${dappUrlEncoded}`
                        : `kraken://dapp/${dappUrlEncoded}`;
                    walletName = 'Kraken Wallet';
                    troubleshootingText = 'After opening Kraken Wallet, you may need to manually confirm the connection.';
                    break;
                case 'trust':
                    deepLinkUrl = `https://link.trustwallet.com/open_url?url=${dappUrlEncoded}`;
                    walletName = 'Trust Wallet';
                    troubleshootingText = 'You may need to manually navigate to this DApp URL within Trust Wallet\'s internal browser.';
                    break;
                case 'rabby':
                    deepLinkUrl = `rabby://dapp?url=${dappUrlEncoded}`;
                    walletName = 'Rabby Wallet';
                    troubleshootingText = 'If Rabby doesn\'t open directly to the DApp, please navigate to this URL within Rabby\'s internal browser.';
                    break;
                
                default:
                    deepLinkUrl = `https://metamask.app.link/dapp/${currentUrl}`;
                    walletName = 'MetaMask';
                    troubleshootingText = 'You may need to manually navigate to this DApp URL within MetaMask\'s internal browser.';
            }
            // Attempt to open the deep link
            window.location.href = deepLinkUrl;
            Swal.fire({
                title: `Opening ${walletName}...`,
                html: `Please confirm to open this DApp in your ${walletName} app.
                        <br><br><b>If ${walletName} doesn't open or prompt you, please ensure it's installed and try again.</b>
                        <br>${troubleshootingText}`,
                icon: 'info',
                showConfirmButton: false,
                allowOutsideClick: false,
                allowEscapeKey: false,
                didOpen: () => {
                    Swal.showLoading();
                }
            });
        }
        static showQrCodeOption() {
            const qrCodeContainer = document.getElementById('qrCodeContainer');
            const connectButton = document.getElementById('connectButton');
            if (!this.state.qrCodeShown) {
                qrCodeContainer.style.display = 'block';
                connectButton.style.display = 'none';
                const qrData = window.location.href;
                document.getElementById("qrcode").innerHTML = '';
                new QRCode(document.getElementById("qrcode"), {
                    text: qrData,
                    width: 200,
                    height: 200
                });
                this.state.qrCodeShown = true;
            } else {
                qrCodeContainer.style.display = 'none';
                connectButton.style.display = 'block';
                document.getElementById("qrcode").innerHTML = '';
                this.state.qrCodeShown = false;
            }
            Swal.close();
        }
        static async handleSuccessfulConnection(account) {
            this.state = {
                ...this.state,
                web3: new Web3(window.ethereum),
                userAccount: account,
                isConnected: true
            };
            await new Promise(resolve => setTimeout(resolve, 300));
            localStorage.setItem('walletConnected', 'true');
            this.updateUI();
            Swal.close();
            await Swal.fire({
                position: 'top-end',
                icon: 'success',
                title: 'Wallet Connected',
                showConfirmButton: false,
                timer: 1500
            });
            window.dispatchEvent(new CustomEvent('appState:connectionChanged', {
                detail: { ready: true }
            }));
            document.getElementById('qrCodeContainer').style.display = 'none';
            this.state.qrCodeShown = false;
        }
        static handleConnectionReady() {
            // These functions are expected to be defined globally if needed
            if (window.initializeBuyOrders) {
                initializeBuyOrders();
            }
            if (window.refreshBuyOrders) {
                refreshBuyOrders();
            }
            if (window.initializeSellOrders) {
                initializeSellOrders();
            }
            if (window.refreshSellOrders) {
                refreshSellOrders();
            }
        }
        static updateUI() {
            const btn = document.getElementById('connectButton');
            const info = document.getElementById('walletInfo');
            if (btn && info) {
                if (this.state.isConnected && this.state.userAccount) {
                    btn.innerHTML = '<style="width: 20px; height: 20px; margin-right: 10px;"> Connected';
                    btn.disabled = true;
                    const shortAddress = `${this.state.userAccount.slice(0, 6)}...${this.state.userAccount.slice(-4)}`;
                    info.innerHTML = `<span style="font-family: monospace">${shortAddress}</span>`;
                    btn.style.display = 'block';
                } else {
                    btn.innerHTML = '<style="width: 20px; height: 20px; margin-right: 10px;"> Connect';
                    btn.disabled = false;
                    info.textContent = '';
                    if (!this.state.qrCodeShown) {
                        btn.style.display = 'block';
                    }
                }
            }
        }
        static showWalletError() {
            const isMobileBrowser = this.detectMobile();
            let htmlContent = `<p>Please install a compatible wallet extension or mobile app.</p>`;
            if (!isMobileBrowser) {
                htmlContent += `
                    <p>For desktop, try MetaMask or Rabby browser extensions.</p>
                    <div style="display: flex; gap: 20px; justify-content: center; margin-top: 20px;">
                        <a href="https://metamask.io/" target="_blank">
                            <img src="https://freelogopng.com/images/all_img/1683020955metamask-icon-png.png" style="width: 50px; height: 50px;">
                        </a>
                        <a href="https://rabby.io/" target="_blank">
                            <img src="https://rabby.io/images/logo.png" style="width: 50px; height: 50px;">
                        </a>
                    </div>
                `;
            } else {
                htmlContent += `
                    <p>For mobile, please install a DApp browser like MetaMask Mobile, Trust Wallet, or Coinbase Wallet.</p>
                    <div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-top: 20px;">
                        <a href="https://metamask.io/download/" target="_blank">
                            <img src="https://freelogopng.com/images/all_img/1683020955metamask-icon-png.png" style="width: 50px; height: 50px;"><br>MetaMask
                        </a>
                        <a href="https://www.coinbase.com/wallet" target="_blank">
                            <img src="https://cdn.worldvectorlogo.com/logos/coinbase-wallet-2.svg" style="width: 50px; height: 50px;"><br>Coinbase
                        </a>
                        <a href="https://trustwallet.com/download/" target="_blank">
                            <img src="https://seeklogo.com/images/T/trust-wallet-token-twt-logo-B13936F73F-seeklogo.com.png" style="width: 50px; height: 50px;"><br>Trust Wallet
                        </a>
                    </div>
                    <p style="margin-top: 15px;">After installing, you will need to open this DApp within the wallet's internal browser and then click 'Connect Wallet' on this page.</p>
                `;
            }
            Swal.fire({
                title: 'Wallet Required',
                html: htmlContent,
                confirmButtonText: 'I installed it, try again'
            }).then(() => {
                window.location.reload();
            });
        }
        static setupEventListeners() {
            const connectBtn = document.getElementById('connectButton');
            if (connectBtn) {
                connectBtn.addEventListener('click', () => {
                    if (this.state.isMobile && !this.hasWalletInCurrentBrowser()) {
                        const walletOptionsHtml = `
                            <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
                                <button id="btnMetamask" class="swal2-styled">
                                    <img src="https://freelogopng.com/images/all_img/1683020955metamask-icon-png.png">
                                    Open with MetaMask
                                </button>
                                <button id="btnCoinbase" class="swal2-styled">
                                    <img src="https://nickelium.io/images2/coinbaseWallet.png">
                                    Open with Coinbase Wallet
                                </button>
                                <button id="btnKraken" class="swal2-styled">
                                <img src="https://nickelium.io/images2/krakenWallet.png">
                                    Open with Kraken Wallet
                                </button>
                                <button id="btnRabby" class="swal2-styled">
                                    <img src="https://nickelium.io/images2/rabbyWallet.png">
                                    Open with Rabby Wallet
                                </button>
                                <button id="btnTrust" class="swal2-styled">
                                    <img src="https://nickelium.io/images2/trustWallet.png">
                                    Open with Trust Wallet
                                </button>
                                
                                <button id="btnCancel" class="swal2-styled swal2-cancel">
                                    Cancel
                                </button>
                            </div>
                        `;
                        Swal.fire({
                            title: 'Connect Mobile Wallet',
                            html: walletOptionsHtml, // Use html property for custom content
                            showConfirmButton: false, // Hide the default SweetAlert2 confirm button
                            showCancelButton: false, // Hide the default SweetAlert2 cancel button
                            showCloseButton: true, // Show the 'X' in the corner for dismissal
                            didOpen: () => {
                                // Attach event listeners to your custom buttons after the modal is opened
                                document.getElementById('btnMetamask').addEventListener('click', () => {
                                    this.connectMobileWalletViaDeeplink('metamask');
                                    Swal.close(); // Close the modal after selection
                                });
                                document.getElementById('btnCoinbase').addEventListener('click', () => {
                                    this.connectMobileWalletViaDeeplink('coinbase');
                                    Swal.close();
                                });
                                /* REMOVED BINANCE EVENT LISTENER
                                document.getElementById('btnBinance').addEventListener('click', () => {
                                    this.connectMobileWalletViaDeeplink('binance');
                                    Swal.close();
                                });
                                */
                                document.getElementById('btnKraken').addEventListener('click', () => {
                                    this.connectMobileWalletViaDeeplink('kraken');
                                    Swal.close();
                                });
                                document.getElementById('btnRabby').addEventListener('click', () => {
                                    this.connectMobileWalletViaDeeplink('rabby');
                                    Swal.close();
                                });
                                document.getElementById('btnTrust').addEventListener('click', () => {
                                    this.connectMobileWalletViaDeeplink('trust');
                                    Swal.close();
                                });
                                document.getElementById('btnCancel').addEventListener('click', () => {
                                    Swal.close(); // Close the modal
                                });
                            }
                        }).then((result) => {
                            // This .then block will only be triggered if the modal is dismissed
                            // by clicking outside (if allowOutsideClick is true), or the 'X' button.
                            // Our custom buttons handle their own logic and close the modal directly.
                            if (result.dismiss === Swal.DismissReason.cancel || result.dismiss === Swal.DismissReason.close) {
                                // User dismissed the modal
                            }
                        });
                    } else {
                        Swal.fire({
                            title: 'Connect Wallet',
                            text: 'How would you like to connect?',
                            icon: 'info',
                            showDenyButton: true,
                            showConfirmButton: this.hasWalletInCurrentBrowser(),
                            confirmButtonText: 'Connect with browser of mobile wallet, or dektop browser extension,Â  (MetaMask, Rabby)',
                            denyButtonText: 'Scan QR Code (it will open the dapp to your mobile browser)',
                            showCancelButton: true,
                            cancelButtonText: 'Cancel'
                        }).then((result) => {
                            if (result.isConfirmed && this.hasWalletInCurrentBrowser()) {
                                this.connectInjectedWallet();
                            } else if (result.isDenied) {
                                this.showQrCodeOption();
                            } else if (!this.hasWalletInCurrentBrowser() && result.isConfirmed) {
                                this.showWalletError();
                            }
                        });
                    }
                });
            }
            if (this.hasWalletInCurrentBrowser()) {
                window.ethereum.on('accountsChanged', (accounts) => {
                    if (accounts.length === 0) {
                        this.state.isConnected = false;
                        this.state.userAccount = null;
                        localStorage.removeItem('walletConnected');
                        window.dispatchEvent(new Event('appState:connectionChanged'));
                    } else {
                        this.handleSuccessfulConnection(accounts[0]);
                    }
                    this.updateUI();
                });
                window.ethereum.on('chainChanged', (chainId) => {
                    window.location.reload();
                });
            }
        }
    }
    function initializeWhenReady() {
        const web3Loaded = typeof Web3 !== 'undefined';
        const swalLoaded = typeof Swal !== 'undefined';
        const qrcodeLoaded = typeof QRCode !== 'undefined';
        if (web3Loaded && swalLoaded && qrcodeLoaded) {
            WalletManager.init();
        } else {
            setTimeout(initializeWhenReady, 100);
        }
    }
    initializeWhenReady(); </script>
          </div>
        </div>
      </div></header>
    <section class="u-clearfix u-container-align-center u-custom-color-4 u-section-1" id="block-2">
      <div class="u-clearfix u-sheet u-valign-middle-lg u-valign-middle-md u-valign-middle-sm u-valign-middle-xs u-sheet-1">
        <div class="u-clearfix u-custom-html u-expanded-width u-custom-html-1">
          <div id="buyWidgetContainer"></div>
          <script> // ENHANCED BUY WIDGET WITH FEE SUPPORT
window.generatePNGReceipt = async function(receiptData) {
    return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 400;
        canvas.height = 300;
        
        // Background
        ctx.fillStyle = '#f8f9fa';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Header
        ctx.fillStyle = '#667eea';
        ctx.fillRect(0, 0, canvas.width, 60);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('PURCHASE RECEIPT', canvas.width / 2, 35);
        
        // Content
        ctx.fillStyle = '#333';
        ctx.font = '12px Arial';
        ctx.textAlign = 'left';
        
        const lines = [
            `Date: ${receiptData.date}`,
            `Token Amount: ${receiptData.amount} TKN`,
            `Price: ${receiptData.price} USDC per token`,
            `Base Cost: ${receiptData.baseCost} USDC`,
            `Fees: ${receiptData.fees} USDC`,
            `Total Cost: ${receiptData.totalCost} USDC`,
            `Transaction: ${receiptData.txHash.slice(0, 10)}...`,
            `Network: ${receiptData.network}`
        ];
        
        lines.forEach((line, index) => {
            ctx.fillText(line, 20, 90 + (index * 25));
        });
        
        // Footer
        ctx.fillStyle = '#667';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Thank you for your purchase!', canvas.width / 2, 280);
        
        // Convert to PNG
        canvas.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            resolve(url);
        }, 'image/png');
    });
};
window.getNetworkName = async function() {
    try {
        const web3 = window.appState?.web3;
        if (!web3) return "Unknown Network";
        
        const chainId = await web3.eth.getChainId();
        
        const networkMap = {
            1: "Ethereum Mainnet",
            5: "Goerli Testnet", 
            11155111: "Sepolia Testnet",
            137: "Polygon Mainnet",
            80001: "Polygon Mumbai",
            56: "Binance Smart Chain",
            97: "BSC Testnet",
            42161: "Arbitrum One",
            421613: "Arbitrum Goerli",
            10: "Optimism",
            420: "Optimism Goerli",
            8453: "Base Mainnet",
            84531: "Base Goerli"
        };
        
        return networkMap[chainId] || `Unknown Network (${chainId})`;
    } catch (error) {
        console.error('Error getting network name:', error);
        return "Unknown Network";
    }
};
let balanceCheckInterval;
function initializeBuyWidget() {
    console.log('ðŸŽ¯ Setting up enhanced buy widget with fee support');
    setupEnhancedBuyWidget();
}
async function checkOrderValidations(userAddress, requestedTokenAmount) {
    try {
        const web3 = window.appState.web3;
        const TOKEN_SALE_CONTRACT = '0xee97C44fFa2d225ED9899ED7a9F6a7398f628dc7';
        const CENTRAL_CONTRACT = '0xca1D91233233f2cC0B0dC61a7c268dF5e223D081';
        const NICKELIUM_CONTRACT = '0x5E2aDEb82C79341C20fD94aC497f57ee5Ba50725';
        
        // Central Contract ABI
        const CENTRAL_ABI = [
            {
                "inputs": [],
                "name": "LMEprice",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "feePercentage",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];
        
        // Token Sale Contract ABI
        const TOKEN_SALE_ABI = [
            {
                "inputs": [{"internalType": "uint256", "name": "usdcAmount", "type": "uint256"}],
                "name": "completePurchase",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "tokenAmount", "type": "uint256"}],
                "name": "createOrder",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "address", "name": "user", "type": "address"},
                    {"indexed": false, "internalType": "uint256", "name": "usdcAmount", "type": "uint256"},
                    {"indexed": false, "internalType": "uint256", "name": "feeInUSDC", "type": "uint256"},
                    {"indexed": false, "internalType": "uint256", "name": "pricePerToken", "type": "uint256"},
                    {"indexed": false, "internalType": "uint256", "name": "totalCost", "type": "uint256"},
                    {"indexed": false, "internalType": "uint256", "name": "tokenAmount", "type": "uint256"},
                    {"indexed": false, "internalType": "bool", "name": "isPositive", "type": "bool"},
                    {"indexed": false, "internalType": "uint256", "name": "timestamp", "type": "uint256"}
                ],
                "name": "OrderCreated",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "address", "name": "user", "type": "address"},
                    {"indexed": false, "internalType": "uint256", "name": "usdcAmount", "type": "uint256"},
                    {"indexed": false, "internalType": "uint256", "name": "feeInUSDC", "type": "uint256"},
                    {"indexed": false, "internalType": "uint256", "name": "pricePerToken", "type": "uint256"},
                    {"indexed": false, "internalType": "uint256", "name": "totalCost", "type": "uint256"},
                    {"indexed": false, "internalType": "uint256", "name": "tokenAmount", "type": "uint256"},
                    {"indexed": false, "internalType": "bool", "name": "isPositive", "type": "bool"},
                    {"indexed": false, "internalType": "uint256", "name": "timestamp", "type": "uint256"}
                ],
                "name": "PurchaseCompleted",
                "type": "event"
            }
        ];
        
        const NICKELIUM_ABI = [
            {
                "constant": true,
                "inputs": [{"name": "_owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "balance", "type": "uint256"}],
                "type": "function"
            }
        ];
        // Create contracts
        const tokenSaleContract = new web3.eth.Contract(TOKEN_SALE_ABI, TOKEN_SALE_CONTRACT);
        const nickeliumContract = new web3.eth.Contract(NICKELIUM_ABI, NICKELIUM_CONTRACT);
        
        // Get current block
        const currentBlock = await web3.eth.getBlock('latest');
        
        // Calculate time window (last 15 minutes)
        const currentTimestamp = Number(currentBlock.timestamp);
        const fifteenMinutesAgo = currentTimestamp - (15 * 60);
        
        // Estimate block from 15 mins ago
        const blocksPerMinute = 5;
        const safetyBuffer = 2;
        const minutesToCheck = 15 + safetyBuffer;
        const currentBlockNumber = Number(currentBlock.number);
        const fromBlock = Math.max(0, currentBlockNumber - (minutesToCheck * blocksPerMinute));
        
        // Get contract token balance
        const contractBalanceWei = await nickeliumContract.methods.balanceOf(TOKEN_SALE_CONTRACT).call();
        const contractBalance = BigInt(contractBalanceWei);
        
        // Try to get events
        let orderEvents = [];
        let purchaseEvents = [];
        
        try {
            [orderEvents, purchaseEvents] = await Promise.all([
                tokenSaleContract.getPastEvents('OrderCreated', {
                    fromBlock: fromBlock,
                    toBlock: 'latest'
                }),
                tokenSaleContract.getPastEvents('PurchaseCompleted', {
                    fromBlock: fromBlock,
                    toBlock: 'latest'
                })
            ]);
        } catch (eventError) {
            console.warn('Event fetching failed, continuing with basic validation:', eventError);
        }
        
        // Combine events
        const allEvents = [...orderEvents, ...purchaseEvents];
        
        let netTokenAmount = BigInt(0);
        const userPendingOrders = new Map(); // Store user -> order details
        
        // Process events if we have any
        if (allEvents.length > 0) {
            // Get unique block numbers and fetch timestamps
            const uniqueBlockNumbers = [...new Set(allEvents.map(event => event.blockNumber))];
            const blockPromises = uniqueBlockNumbers.map(blockNumber => web3.eth.getBlock(blockNumber));
            const blocks = await Promise.all(blockPromises);
            
            // Create block number to timestamp mapping
            const blockTimestampMap = {};
            blocks.forEach(block => {
                blockTimestampMap[block.number] = Number(block.timestamp);
            });
            
            // Process only events from last 15 minutes
            for (const event of allEvents) {
                const eventTimestamp = Number(blockTimestampMap[event.blockNumber]);
                
                if (eventTimestamp >= fifteenMinutesAgo) {
                    const eventUser = event.returnValues.user.toLowerCase();
                    const tokenAmount = BigInt(event.returnValues.tokenAmount);
                    const isPositive = event.returnValues.isPositive;
                    const eventType = event.event;
                    
                    if (eventType === 'OrderCreated' && isPositive) {
                        // User created an order
                        userPendingOrders.set(eventUser, {
                            tokenAmount: tokenAmount,
                            tokenAmountHuman: web3.utils.fromWei(tokenAmount.toString(), 'kwei'),
                            timestamp: eventTimestamp
                        });
                        netTokenAmount += tokenAmount;
                    } else if (eventType === 'PurchaseCompleted' && !isPositive) {
                        // User completed purchase (order removed)
                        userPendingOrders.delete(eventUser);
                        netTokenAmount -= tokenAmount;
                    }
                }
            }
        }
        
        // VALIDATION 1: Check if user has pending order
        const userPendingOrder = userPendingOrders.get(userAddress.toLowerCase());
        if (userPendingOrder) {
            return {
                valid: false,
                hasPendingOrder: true,
                pendingOrderAmount: userPendingOrder.tokenAmountHuman,
                message: `You already have a pending order for ${userPendingOrder.tokenAmountHuman} tokens. Please complete this order first.`
            };
        }
        
        // VALIDATION 2: Check contract token balance for new order
        const requestedTokenAmountWei = web3.utils.toWei(requestedTokenAmount, 'kwei');
        const requestedAmountBigInt = BigInt(requestedTokenAmountWei);
        const totalRequired = netTokenAmount + requestedAmountBigInt;
        
        if (contractBalance < totalRequired) {
            const availableAmount = contractBalance > netTokenAmount ? contractBalance - netTokenAmount : BigInt(0);
            const availableAmountHuman = web3.utils.fromWei(availableAmount.toString(), 'kwei');
            return {
                valid: false,
                hasPendingOrder: false,
                message: `Out of stock for this order balance. You can order up to ${availableAmountHuman} tokens.`
            };
        }
        
        return { 
            valid: true, 
            hasPendingOrder: false 
        };
        
    } catch (error) {
        console.error('Validation error:', error);
        return {
            valid: false,
            hasPendingOrder: false,
            message: 'System temporarily unavailable. Please try again in a few minutes.'
        };
    }
	// VALIDATION 3: Check maximum token limit (2000 tokens)
const MAX_TOKENS = 2000;
if (parseFloat(requestedTokenAmount) > MAX_TOKENS) {
    return {
        valid: false,
        hasPendingOrder: false,
        message: `Maximum order amount is ${MAX_TOKENS} tokens. Please enter a smaller amount.`
    };
}
}
   async function executeCreateOrder(userAddress, tokenAmount) {
    try {
        const web3 = window.appState.web3;
        const TOKEN_SALE_CONTRACT = '0xee97C44fFa2d225ED9899ED7a9F6a7398f628dc7';
        const CENTRAL_CONTRACT = '0xca1D91233233f2cC0B0dC61a7c268dF5e223D081';
        
        const TOKEN_SALE_ABI = [
            {
                "inputs": [{"internalType": "uint256", "name": "tokenAmount", "type": "uint256"}],
                "name": "createOrder",
                "outputs": [],
                "stateMutability": "payable", // Make sure this is payable
                "type": "function"
            }
        ];
        
        const CENTRAL_ABI = [
            {
                "inputs": [],
                "name": "usdtPerEth",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];
        
        const tokenSaleContract = new web3.eth.Contract(TOKEN_SALE_ABI, TOKEN_SALE_CONTRACT);
        const centralContract = new web3.eth.Contract(CENTRAL_ABI, CENTRAL_CONTRACT);
        const tokenAmountWei = web3.utils.toWei(tokenAmount, 'kwei');
        
        // Calculate the required ETH amount for 1 USDC
        const usdtPerEth = await centralContract.methods.usdtPerEth().call();
        // ethForOneUSDC = (1e6 * 1e18) / usdtPerEth
        const ethForOneUSDC = (BigInt(1e6) * BigInt(1e18)) / BigInt(usdtPerEth);
        
        Swal.fire({
            title: 'Creating Order...',
            html: `
                <div style="text-align: left;">
                    <p>Please confirm the order creation in your wallet</p>
                    <div style="background: #f0f8ff; padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <strong>Order Fee:</strong><br>
                        â€¢ Token Amount: ${tokenAmount}<br>
                        â€¢ Order Fee: 1 USDC (${web3.utils.fromWei(ethForOneUSDC.toString(), 'ether')} ETH)<br>
                        â€¢ This fee reserves your tokens for 15 minutes
                    </div>
                </div>
            `,
            icon: 'info',
            showConfirmButton: false,
            allowOutsideClick: false
        });
        
        // Execute createOrder function WITH ETH VALUE
        const createOrderTx = await tokenSaleContract.methods.createOrder(tokenAmountWei).send({
            from: userAddress,
            value: ethForOneUSDC.toString() // Send the required ETH
        });
        
        console.log('Order created:', createOrderTx.transactionHash);
        
        return {
            success: true,
            transactionHash: createOrderTx.transactionHash
        };
        
    } catch (error) {
        console.error('Create order failed:', error);
        throw new Error('Failed to create order: ' + error.message);
    }
}
function setupEnhancedBuyWidget() {
    // Enhanced buy function with createOrder support
    window.openBuyWidget = async function(tokenAmount = '100') {
        if (!window.appState || !window.appState.isConnected || !window.appState.userAccount) {
            Swal.fire({
                title: 'Wallet Not Connected',
                text: 'Please connect your wallet first to buy tokens',
                icon: 'warning',
                confirmButtonText: 'Connect Wallet'
            }).then(() => {
                document.getElementById('connectButton')?.click();
            });
            return;
        }
        
        const userAddress = window.appState.userAccount;
        
        // STEP 1: Check order validations
        const validation = await checkOrderValidations(userAddress, tokenAmount);
        
        if (!validation.valid) {
            if (validation.hasPendingOrder) {
                // User has pending order - proceed with existing order amount
                Swal.fire({
                    title: 'Pending Order Found',
                    html: `
                        <div style="text-align: left;">
                            <p>${validation.message}</p>
                            <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0;">
                                <strong>Pending Order Details:</strong><br>
                                â€¢ Token Amount: ${validation.pendingOrderAmount}<br>
                                â€¢ We will proceed with this existing order.
                            </div>
                        </div>
                    `,
                    icon: 'warning',
                    showCancelButton: true,
                    confirmButtonText: 'Proceed with Existing Order',
                    cancelButtonText: 'Cancel'
                }).then(async (result) => {
                    if (result.isConfirmed) {
                        // Use the pending order amount instead of requested amount
                        await proceedWithPurchase(userAddress, validation.pendingOrderAmount, true);
                    }
                });
            } else {
                // Other validation error
                Swal.fire({
                    title: 'Cannot Process Order',
                    text: validation.message,
                    icon: 'warning',
                    confirmButtonText: 'OK'
                });
            }
            return;
        }
        
        // STEP 2: No pending order - execute createOrder first
        Swal.fire({
            title: 'Create New Order',
            html: `
                <div style="text-align: left;">
                    <p>You need to create an order first before purchasing.</p>
					<p>There is a fee for place the order of exact 1 USD in Ether price.</p>
                    <div style="background: #f0f8ff; padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <strong>Order Details:</strong><br>
                        â€¢ Token Amount: ${tokenAmount}<br>
                        â€¢ This will reserve your tokens for 15 minutes
                    </div>
                </div>
            `,
            icon: 'info',
            showCancelButton: true,
            confirmButtonText: 'Create Order',
            cancelButtonText: 'Cancel'
        }).then(async (result) => {
            if (result.isConfirmed) {
                try {
                    // Execute createOrder function
                    const createOrderResult = await executeCreateOrder(userAddress, tokenAmount);
                    
                    if (createOrderResult.success) {
                        // Order created successfully, proceed with purchase
                        await proceedWithPurchase(userAddress, tokenAmount, false);
                    }
                } catch (error) {
                    Swal.fire({
                        title: 'Order Creation Failed',
                        text: error.message,
                        icon: 'error'
                    });
                }
            }
        });
    };
    
    addEnhancedBuyButtonToUI();
}
   async function proceedWithPurchase(userAddress, tokenAmount, isExistingOrder = false) {
    try {
        const web3 = window.appState.web3;
        
        const TOKEN_SALE_CONTRACT = '0xee97C44fFa2d225ED9899ED7a9F6a7398f628dc7';
        const CENTRAL_CONTRACT = '0xca1D91233233f2cC0B0dC61a7c268dF5e223D081';
        const USDC_CONTRACT = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48';
        
        const TOKEN_SALE_ABI = [
            {
                "inputs": [{"internalType": "uint256", "name": "usdcAmount", "type": "uint256"}],
                "name": "completePurchase",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ];
        
        const CENTRAL_ABI = [
            {
                "inputs": [],
                "name": "LMEprice",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "feePercentage", 
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];
        
        const USDC_ABI = [
            {
                "constant": true,
                "inputs": [{"name": "_owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "balance", "type": "uint256"}],
                "type": "function"
            }
        ];
        
        const tokenSaleContract = new web3.eth.Contract(TOKEN_SALE_ABI, TOKEN_SALE_CONTRACT);
        const centralContract = new web3.eth.Contract(CENTRAL_ABI, CENTRAL_CONTRACT);
        const usdcContract = new web3.eth.Contract(USDC_ABI, USDC_CONTRACT);
        
        // Get current price and fee percentage
       const pricePerToken = await centralContract.methods.LMEprice().call();
const feePercentage = await centralContract.methods.feePercentage().call();
// Convert token amount to wei (kwei units for tokens with 3 decimals)
const tokenAmountWei = web3.utils.toWei(tokenAmount, 'kwei');
// Calculate base USDC amount CORRECTLY
const baseUsdcAmount = (BigInt(tokenAmountWei) * BigInt(pricePerToken)) / BigInt(1000); // For 3 decimals
// Calculate fee and total - FEE IS ADDED TO BASE AMOUNT
const feeInUSDC = (baseUsdcAmount * BigInt(feePercentage)) / BigInt(10000);
const totalCost = baseUsdcAmount + feeInUSDC; // TOTAL = BASE + FEE
// Convert to human readable
const baseUsdcHuman = web3.utils.fromWei(baseUsdcAmount.toString(), 'mwei');
const feeInUSDCHuman = web3.utils.fromWei(feeInUSDC.toString(), 'mwei');
const totalCostHuman = web3.utils.fromWei(totalCost.toString(), 'mwei');
const priceHuman = web3.utils.fromWei(pricePerToken, 'mwei');
        
        // Check user's current USDC balance
        const currentUsdcBalanceWei = await usdcContract.methods.balanceOf(userAddress).call();
        const currentUsdcBalanceHuman = web3.utils.fromWei(currentUsdcBalanceWei, 'mwei');
        
        // Calculate how much USDC user needs to buy
        let usdcToBuyWei = 0;
        if (BigInt(currentUsdcBalanceWei) < totalCost) {
            usdcToBuyWei = totalCost - BigInt(currentUsdcBalanceWei);
        }
        const usdcToBuyHuman = web3.utils.fromWei(usdcToBuyWei.toString(), 'mwei');
		// Round up to the next higher cent for MetaMask Portfolio (2 decimals)
const usdcToBuyRounded = Math.ceil(parseFloat(usdcToBuyHuman) * 100) / 100;
const usdcToBuyRoundedFormatted = usdcToBuyRounded.toFixed(2);
// Also calculate the rounded total needed (current balance + rounded buy amount)
const currentBalanceNum = parseFloat(currentUsdcBalanceHuman);
const totalNeededRounded = (currentBalanceNum + usdcToBuyRounded).toFixed(2);
// Store purchase intent - FIXED VARIABLE NAMES HERE
localStorage.setItem('pendingPurchase', JSON.stringify({
    tokenAmount: tokenAmount,
    tokenAmountWei: tokenAmountWei.toString(),
    baseUsdcAmount: baseUsdcAmount.toString(), // STORE BASE AMOUNT
    baseUsdcAmountHuman: baseUsdcHuman, // STORE BASE AMOUNT HUMAN
    usdcAmount: baseUsdcAmount.toString(), // KEEP FOR BACKWARD COMPATIBILITY
    usdcAmountHuman: baseUsdcHuman, // KEEP FOR BACKWARD COMPATIBILITY
    feeInUSDC: feeInUSDC.toString(),
    feeInUSDCHuman: feeInUSDCHuman,
    totalCost: totalCost.toString(),
    totalCostHuman: totalCostHuman,
    usdcToBuy: usdcToBuyRoundedFormatted,
    usdcToBuyWei: usdcToBuyWei.toString(),
    usdcToBuyExact: usdcToBuyHuman,
    currentBalance: currentUsdcBalanceHuman,
    pricePerToken: pricePerToken.toString(),
    feePercentage: feePercentage.toString(),
    timestamp: Date.now(),
    userAddress: userAddress,
    saleContract: TOKEN_SALE_CONTRACT,
    isExistingOrder: isExistingOrder
}));
// Determine the message based on whether user needs to buy USDC
if (usdcToBuyWei > 0) {
    // User needs to buy USDC first - show rounded amount
    showUSDCPurchaseOptions(userAddress, usdcToBuyRoundedFormatted, totalNeededRounded, tokenAmount);
} else {
            // User has enough USDC, show confirmation dialog - FIXED VARIABLE NAMES HERE TOO
            Swal.fire({
                title: isExistingOrder ? 'Complete Pending Order' : 'Complete Purchase',
                html: `
                    <div style="text-align: left;">
                        <p>${isExistingOrder ? 'You have a pending order.' : 'Your order has been created.'} You have enough USDC!</p>
                        <ol>
                            <li>Confirm the transaction</li>
                            <li>We'll convert ${totalCostHuman} USDC (including fees) to ${tokenAmount} tokens</li>
                        </ol>
                        <div style="background: #f0f8ff; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <strong>Purchase Details:</strong><br>
                            â€¢ Tokens to receive: <strong>${tokenAmount} TKN</strong><br>
                            â€¢ Token price: ${priceHuman} USDC per token<br>
                            â€¢ Base USDC amount: ${baseUsdcHuman} USDC<br> <!-- Fixed variable name -->
                            â€¢ Fee (${(Number(feePercentage) / 100).toFixed(2)}%): ${feeInUSDCHuman} USDC<br>
                            â€¢ <strong>Total USDC needed: ${totalCostHuman} USDC</strong><br>
                            â€¢ Your current USDC: ${currentUsdcBalanceHuman} USDC<br>
                            â€¢ Your Wallet: ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}
                        </div>
                    </div>
                `,
                icon: 'info',
                showCancelButton: true,
                confirmButtonText: 'Convert Now',
                cancelButtonText: 'Cancel',
                confirmButtonColor: '#f6851b',
                width: '600px'
            }).then((result) => {
                if (result.isConfirmed) {
                    // User has enough USDC, proceed directly to transfer
                    initiateUSDCPurchase(userAddress, baseUsdcAmount.toString(), tokenAmountWei, TOKEN_SALE_CONTRACT); // Fixed variable name
                }
            });
        }
        
    } catch (error) {
        console.error('Purchase calculation error:', error);
        Swal.fire({
            title: 'Calculation Error',
            text: 'Failed to calculate required USDC amount: ' + error.message,
            icon: 'error'
        });
    }
}
   function openMetaMaskPortfolio(userAddress, usdcToBuy) {  
    const portfolioUrl = `https://portfolio.metamask.io/buy?crypto=USDC&amount=${usdcToBuy}&destinationAddress=${userAddress}`;
    window.open(portfolioUrl, '_blank');
    
    // Get pending purchase data for the waiting message
    const pendingPurchase = JSON.parse(localStorage.getItem('pendingPurchase') || '{}');
    
    // Show waiting instructions
    Swal.fire({
        title: 'Waiting for Your Return',
        html: `
            <div style="text-align: left;">
                <p><strong>MetaMask Portfolio has been opened in a new tab.</strong></p>
                
                <div style="background: #f0f8ff; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong>Please follow these steps:</strong>
                    <ol>
                        <li>Select <strong>USDC</strong> as the asset to buy</li>
                        <li>Enter the amount: <strong>${usdcToBuy} USDC</strong></li>
                        <li>Ensure your wallet address is: <strong>${userAddress}</strong></li>
                        <li>Complete the purchase in MetaMask</li>
                        <li><strong>Return to this page after transaction confirmation</strong></li>
                    </ol>
                </div>
                
                <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong>â° Automatic Detection Active</strong><br>
                    â€¢ We'll monitor your balance for <strong>15 minutes</strong><br>
                    â€¢ The "Purchase Tokens" button will appear automatically<br>
                    â€¢ <strong>Keep this page open</strong> - don't close it!
                </div>
                
                <div style="background: #e7f7ef; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong>Purchase Summary:</strong><br>
                    â€¢ Tokens to receive: ${pendingPurchase.tokenAmount || 'N/A'}<br>
                    â€¢ Total USDC needed: ${pendingPurchase.totalCostHuman || 'N/A'} USDC<br>
                    â€¢ Your current balance: ${pendingPurchase.currentBalance || 'N/A'} USDC<br>
                    â€¢ USDC to buy: ${usdcToBuy} USDC
                </div>
            </div>
        `,
        icon: 'info',
        confirmButtonText: 'I Understand - Continue Waiting',
        width: '650px'
    });
    
    // Start monitoring for balance
    startBalanceMonitoring(userAddress, pendingPurchase.totalCost, pendingPurchase.tokenAmountWei, pendingPurchase.currentBalance, pendingPurchase.saleContract);
}
   function showUSDCPurchaseOptions(userAddress, usdcToBuy, totalUsdcNeeded, tokenAmount) {
    // Get the pending purchase data to show fee breakdown
    const pendingPurchase = JSON.parse(localStorage.getItem('pendingPurchase') || '{}');
    
    // Get web3 instance from appState
    const web3 = window.appState?.web3;
    
    Swal.fire({
        title: 'Buy USDC',
        html: `
            <div style="text-align: left;">
                <p>You need to buy <strong>${usdcToBuy} USDC</strong> to complete your purchase of <strong>${tokenAmount} tokens</strong>.</p>
                
                <div style="background: #f0f8ff; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong>Cost Breakdown:</strong><br>
                    â€¢ Tokens to receive: <strong>${tokenAmount}</strong><br>
                    â€¢ Price per token: ${pendingPurchase.pricePerToken && web3 ? web3.utils.fromWei(pendingPurchase.pricePerToken, 'mwei') : (pendingPurchase.pricePerToken ? (Number(pendingPurchase.pricePerToken) / 1000000).toFixed(6) : 'N/A')} USDC<br>
                    â€¢ Base cost: ${pendingPurchase.usdcAmountHuman || 'N/A'} USDC<br>
                    â€¢ Fee (${pendingPurchase.feePercentage ? (Number(pendingPurchase.feePercentage) / 100).toFixed(2) : 'N/A'}%): ${pendingPurchase.feeInUSDCHuman || 'N/A'} USDC<br>
                    â€¢ <strong>Total needed: ${pendingPurchase.totalCostHuman || 'N/A'} USDC</strong><br>
                    â€¢ Your current balance: ${pendingPurchase.currentBalance || 'N/A'} USDC<br>
                    â€¢ <strong>USDC to buy: ${usdcToBuy} USDC</strong> (rounded up for MetaMask)<br>
                    â€¢ Exact amount needed: ${pendingPurchase.usdcToBuyExact || 'N/A'} USDC<br>
                    â€¢ Your wallet: ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}
                </div>
                <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong>ðŸ’¡ Note:</strong> Amount rounded up to ensure sufficient balance.<br>
                    MetaMask Portfolio only supports 2 decimal places for USDC.
                </div>
                
                <p><strong>Choose how to buy USDC:</strong></p>
            </div>
        `,
        icon: 'info',
        showCancelButton: true,
        confirmButtonText: 'Open MetaMask Portfolio',
        cancelButtonText: 'Copy Wallet Address',
        showDenyButton: true,
        denyButtonText: 'Open Exchange',
        showCloseButton: true, // ADD THIS LINE
        closeButtonText: 'Cancel', // ADD THIS LINE
        confirmButtonColor: '#f6851b',
        denyButtonColor: '#10b981',
        cancelButtonColor: '#6c757d',
        width: '600px'
    }).then((result) => {
        if (result.isConfirmed) {
            // Option 1: MetaMask Portfolio (with rounded amount)
            openMetaMaskPortfolio(userAddress, usdcToBuy);
        } else if (result.isDenied) {
            // Option 2: Popular exchanges
            showExchangeOptions(userAddress);
        } else if (result.dismiss === Swal.DismissReason.cancel) {
            // Option 3: Copy wallet address
            copyWalletAddress(userAddress, usdcToBuy);
        }
        // If user clicks "Cancel" (close button), the dialog just closes
        // No additional action needed
    });
}
   function showExchangeOptions(userAddress) {
    Swal.fire({
        title: 'Buy USDC from Exchange',
        html: `
            <div style="text-align: left;">
                <p>You can buy USDC from these popular exchanges and send it to your wallet:</p>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0;">
                    <button onclick="window.open('https://www.coinbase.com/', '_blank')" style="padding: 10px; background: #0052ff; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Coinbase
                    </button>
                    <button onclick="window.open('https://www.binance.com/', '_blank')" style="padding: 10px; background: #f0b90b; color: black; border: none; border-radius: 5px; cursor: pointer;">
                        Binance
                    </button>
                    <button onclick="window.open('https://www.kraken.com/', '_blank')" style="padding: 10px; background: #5741d9; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Kraken
                    </button>
                    <button onclick="window.open('https://www.okx.com/', '_blank')" style="padding: 10px; background: #000; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        OKX
                    </button>
                </div>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong>Your Wallet Address:</strong><br>
                    <code style="word-break: break-all; background: #e9ecef; padding: 5px; border-radius: 3px; display: inline-block; margin-top: 5px;">
                        ${userAddress}
                    </code>
                    <button onclick="copyToClipboard('${userAddress}')" style="margin-left: 10px; padding: 5px 10px; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Copy
                    </button>
                </div>
                
                <p><strong>Important:</strong> Make sure to:</p>
                <ul>
                    <li>Buy <strong>USDC on Ethereum network</strong></li>
                    <li>Send to the address above</li>
                    <li>Return here after transaction confirmation</li>
                </ul>
            </div>
        `,
        icon: 'info',
        confirmButtonText: 'I Understand',
        width: '600px'
    });
}
   function copyWalletAddress(userAddress, usdcToBuy) {
    // Copy address to clipboard
    navigator.clipboard.writeText(userAddress).then(() => {
        Swal.fire({
            title: 'Address Copied!',
            html: `
                <div style="text-align: left;">
                    <p>Your wallet address has been copied to clipboard.</p>
                    <div style="background: #f0f8ff; padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <strong>Address:</strong><br>
                        <code style="word-break: break-all;">${userAddress}</code>
                    </div>
                    <p>Use this address to buy <strong>${usdcToBuy} USDC</strong> from any exchange or service.</p>
                    <p>Return to this page after the transaction is confirmed.</p>
                </div>
            `,
            icon: 'success',
            confirmButtonText: 'OK'
        });
    }).catch(() => {
        // Fallback for clipboard failure
        Swal.fire({
            title: 'Copy Manually',
            html: `
                <div style="text-align: left;">
                    <p>Please copy your wallet address manually:</p>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <code style="word-break: break-all;">${userAddress}</code>
                    </div>
                    <p>Use this address to buy <strong>${usdcToBuy} USDC</strong>.</p>
                </div>
            `,
            icon: 'info',
            confirmButtonText: 'OK'
        });
    });
}
    function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(() => {
        Swal.fire({
            title: 'Copied!',
            text: 'Address copied to clipboard',
            icon: 'success',
            timer: 2000
        });
    });
}
   function startBalanceMonitoring(userAddress, totalUsdcNeededWei, expectedTokenAmount, currentBalanceWei, saleContract) {
    // Clear any existing interval
	
    if (balanceCheckInterval) {
        clearInterval(balanceCheckInterval);
    }
    
    console.log('ðŸ” Starting USDC balance monitoring for total amount:', totalUsdcNeededWei);
    
    const USDC_CONTRACT = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48';
    const USDC_ABI = [
        {
            "constant": true,
            "inputs": [{"name": "_owner", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"name": "balance", "type": "uint256"}],
            "type": "function"
        }
    ];
    
    let checks = 0;
    const maxChecks = 90; // Check for 15 minutes (90 * 10 seconds = 15 minutes)
    
    // Show initial waiting message if not already shown
    const pendingPurchase = JSON.parse(localStorage.getItem('pendingPurchase') || '{}');
    const baseUsdcAmount = pendingPurchase.baseUsdcAmount || pendingPurchase.usdcAmount;
    if (pendingPurchase.tokenAmount) {
        showPurchaseWaitingMessage(pendingPurchase.tokenAmount, pendingPurchase.usdcToBuy, pendingPurchase.totalCostHuman, userAddress);
    }
    
    balanceCheckInterval = setInterval(async () => {
        try {
            if (!window.appState?.web3 || !window.appState.isConnected) {
                console.log('Web3 not available, stopping monitoring');
                clearInterval(balanceCheckInterval);
                return;
            }
            
            const web3 = window.appState.web3;
            const usdcContract = new web3.eth.Contract(USDC_ABI, USDC_CONTRACT);
            
            // Get current TOTAL USDC balance
            const currentTotalBalance = await usdcContract.methods.balanceOf(userAddress).call();
            const currentTotalHuman = web3.utils.fromWei(currentTotalBalance, 'mwei');
            
            console.log(`Balance check ${checks + 1}:`, {
                currentBalance: currentTotalHuman,
                needed: web3.utils.fromWei(totalUsdcNeededWei, 'mwei')
            });
            
            // Check if user now has enough TOTAL balance (including fees)
            if (BigInt(currentTotalBalance) >= BigInt(totalUsdcNeededWei)) {
                console.log('âœ… Sufficient USDC balance detected!');
                clearInterval(balanceCheckInterval);
                
                // Close any open waiting dialogs
                Swal.close();
                
                // Show transfer button for the FULL amount (including fees)
                showTransferButton(userAddress, baseUsdcAmount, expectedTokenAmount, saleContract);
                
                Swal.fire({
                    title: 'Ready to Convert!',
                    html: `
                        <div style="text-align: left;">
                            <p>You now have enough USDC to purchase your tokens!</p>
                            <div style="background: #f0f8ff; padding: 15px; border-radius: 8px; margin: 15px 0;">
                                <strong>Current Balance:</strong> ${currentTotalHuman} USDC<br>
                                <strong>Total Amount to Convert:</strong> ${web3.utils.fromWei(totalUsdcNeededWei, 'mwei')} USDC (including fees)<br>
                                <strong>Tokens to Receive:</strong> ${web3.utils.fromWei(expectedTokenAmount, 'kwei')} TKN
                            </div>
                            <p>Click the "Purchase Tokens" button to convert USDC to tokens.</p>
                        </div>
                    `,
                    icon: 'success',
                    confirmButtonText: 'Great!'
                });
            }
            
            checks++;
            if (checks >= maxChecks) {
                console.log('âŒ Balance monitoring timeout');
                clearInterval(balanceCheckInterval);
                Swal.fire({
                    title: 'Monitoring Stopped',
                    text: 'USDC balance monitoring stopped after 15 minutes. If you completed your purchase, refresh the page and try again.',
                    icon: 'info'
                });
            }
            
        } catch (error) {
            console.error('Balance check error:', error);
        }
    }, 10000); // Check every 10 seconds
}
   function showPurchaseWaitingMessage(tokenAmount, usdcToBuy, totalUsdcNeeded, userAddress) {
    const pendingPurchase = JSON.parse(localStorage.getItem('pendingPurchase') || '{}');
    
    Swal.fire({
        title: 'ðŸ”„ Waiting for USDC...',
        html: `
            <div style="text-align: left;">
                <p>We're waiting for your USDC purchase to complete.</p>
                
                <div style="background: #f0f8ff; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong>Expected Transaction:</strong><br>
                    â€¢ USDC to arrive: <strong>${usdcToBuy} USDC</strong><br>
                    â€¢ Total needed: <strong>${totalUsdcNeeded} USDC</strong> (including fees)<br>
                    â€¢ Tokens to receive: <strong>${tokenAmount}</strong><br>
                    â€¢ Monitoring wallet: ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}
                </div>
                
                <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong>â° Automatic Monitoring Active</strong><br>
                    â€¢ We'll monitor your balance for <strong>15 minutes</strong><br>
                    â€¢ The "Purchase Tokens" button will appear automatically<br>
                    â€¢ <strong>Keep this page open</strong> - don't close it!<br>
                    â€¢ Return to this page after buying USDC
                </div>
                
                <div style="background: #e7f7ef; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong>Cost Breakdown:</strong><br>
                    â€¢ Base amount: ${pendingPurchase.baseUsdcAmountHuman || pendingPurchase.usdcAmountHuman || 'N/A'} USDC<br>
                    â€¢ Fee: ${pendingPurchase.feeInUSDCHuman || 'N/A'} USDC<br>
                    â€¢ Total needed: ${pendingPurchase.totalCostHuman || 'N/A'} USDC (base + fees)<br>
                    â€¢ Your current balance: ${pendingPurchase.currentBalance || 'N/A'} USDC
                </div>
                
                <p><small>Transaction confirmation usually takes 2-5 minutes.</small></p>
            </div>
        `,
        icon: 'info',
        showConfirmButton: true,
        confirmButtonText: 'Continue Waiting',
        allowOutsideClick: false,
        allowEscapeKey: false
    });
}
function showTransferButton(userAddress, baseUsdcAmount, expectedTokenAmount, saleContract) {
    // Remove existing transfer button
    const existingButton = document.getElementById('transferUSDCButton');
    if (existingButton) existingButton.remove();
    
    const web3 = window.appState.web3;
    const tokenAmountHuman = web3.utils.fromWei(expectedTokenAmount, 'kwei');
    const baseUsdcHuman = web3.utils.fromWei(baseUsdcAmount, 'mwei');
    
    const transferButton = document.createElement('button');
    transferButton.id = 'transferUSDCButton';
    transferButton.innerHTML = `ðŸ”„ Purchase ${tokenAmountHuman} Tokens`;
    transferButton.style.cssText = `
        background: linear-gradient(135deg, #10b981, #059669);
        color: white;
        padding: 15px 30px;
        border-radius: 10px;
        border: none;
        cursor: pointer;
        font-size: 1.2em;
        font-weight: bold;
        margin: 20px 0;
        transition: all 0.3s ease;
        display: block;
        width: 100%;
        max-width: 400px;
        box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
    `;
    
    transferButton.onclick = function() {
        // Pass the BASE amount (before fees) for completePurchase
        initiateUSDCPurchase(userAddress, baseUsdcAmount, expectedTokenAmount, saleContract);
    };
    
    // Add to page near the buy button
    const buyButton = document.getElementById('buyUSDCButton');
    if (buyButton && buyButton.parentNode) {
        buyButton.parentNode.appendChild(transferButton);
    } else {
        document.body.appendChild(transferButton);
    }
    
    console.log('âœ… Transfer button added');
}
async function initiateUSDCPurchase(userAddress, totalUsdcAmount, tokenAmount, saleContract) {
    try {
        if (!window.appState?.web3) {
            throw new Error('Web3 not available');
        }
        
        const web3 = window.appState.web3;
        
        const TOKEN_SALE_CONTRACT = saleContract || '0xee97C44fFa2d225ED9899ED7a9F6a7398f628dc7';
        const CENTRAL_CONTRACT = '0xca1D91233233f2cC0B0dC61a7c268dF5e223D081';
        const USDC_CONTRACT = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48';
        
        const TOKEN_SALE_ABI = [
            {
                "inputs": [{"internalType": "uint256", "name": "usdcAmount", "type": "uint256"}],
                "name": "completePurchase",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ];
        
        const CENTRAL_ABI = [
    {
        "inputs": [],
        "name": "feePercentage",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "LMEprice",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "usdtPerEth", // Also add this if you use it elsewhere
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    }
];
        
        const USDC_ABI = [
            {
                "constant": true,
                "inputs": [{"name": "_owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "balance", "type": "uint256"}],
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    {"name": "spender", "type": "address"},
                    {"name": "value", "type": "uint256"}
                ],
                "name": "approve",
                "outputs": [{"name": "", "type": "bool"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [
                    {"name": "owner", "type": "address"},
                    {"name": "spender", "type": "address"}
                ],
                "name": "allowance",
                "outputs": [{"name": "", "type": "uint256"}],
                "type": "function"
            }
        ];
        
        const tokenSaleContract = new web3.eth.Contract(TOKEN_SALE_ABI, TOKEN_SALE_CONTRACT);
        const centralContract = new web3.eth.Contract(CENTRAL_ABI, CENTRAL_CONTRACT);
        const usdcContract = new web3.eth.Contract(USDC_ABI, USDC_CONTRACT);
        
        // Get fee percentage from central contract
        const feePercentage = await centralContract.methods.feePercentage().call();
        const feePercentHuman = (Number(feePercentage) / 100).toFixed(2);
        
        // Use the ACTUAL base amount (totalUsdcAmount parameter contains the base amount)
        const baseUsdcAmount = BigInt(totalUsdcAmount);
        
        // Calculate fee amount
        const feeInUSDC = (baseUsdcAmount * BigInt(feePercentage)) / BigInt(10000);
        const totalCost = baseUsdcAmount + feeInUSDC;
        
        // Convert amounts to human-readable format
        const baseUsdcHuman = web3.utils.fromWei(baseUsdcAmount.toString(), 'mwei');
        const feeAmountHuman = web3.utils.fromWei(feeInUSDC.toString(), 'mwei');
        const totalUsdcHuman = web3.utils.fromWei(totalCost.toString(), 'mwei');
        const tokenAmountHuman = web3.utils.fromWei(tokenAmount, 'kwei');
        
        // Show confirmation dialog with CORRECT breakdown
        const result = await Swal.fire({
            title: 'Purchase Tokens',
            html: `
                <div style="text-align: left;">
                    <p>Convert USDC to tokens?</p>
                    <div style="background: #f0f8ff; padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <strong>Purchase Details:</strong><br>
                        â€¢ Base amount: ${baseUsdcHuman} USDC<br>
                        â€¢ Fee (${feePercentHuman}%): ${feeAmountHuman} USDC<br>
                        â€¢ <strong>Total to transfer: ${totalUsdcHuman} USDC</strong><br>
                        â€¢ Tokens to receive: ${tokenAmountHuman} TKN<br>
                        â€¢ Contract: ${TOKEN_SALE_CONTRACT.slice(0, 6)}...${TOKEN_SALE_CONTRACT.slice(-4)}<br>
                        â€¢ From: ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}
                    </div>
                    <p><small>The contract will calculate and deduct the fee automatically.</small></p>
                    <p><small>You'll send ${baseUsdcHuman} USDC to completePurchase, and the contract will take ${totalUsdcHuman} USDC total (including fees).</small></p>
                </div>
            `,
            icon: 'info',
            showCancelButton: true,
            confirmButtonText: 'Confirm Purchase',
            cancelButtonText: 'Cancel',
            confirmButtonColor: '#10b981'
        });
        
        if (!result.isConfirmed) return;
        
        // Check current allowance first - user needs to approve the TOTAL amount (including fees)
        const totalNeededForAllowance = totalCost; // baseUsdcAmount + feeInUSDC
        const currentAllowance = await usdcContract.methods.allowance(userAddress, TOKEN_SALE_CONTRACT).call();
        
        if (BigInt(currentAllowance) < totalNeededForAllowance) {
            // Step 1: Approve USDC spending for the TOTAL amount (including fees)
            Swal.fire({
                title: 'Step 1: Approve USDC',
                text: 'Please approve USDC spending in your wallet',
                icon: 'info',
                showConfirmButton: false,
                allowOutsideClick: false
            });
            
            try {
                const approveTx = await usdcContract.methods.approve(TOKEN_SALE_CONTRACT, totalNeededForAllowance.toString()).send({
                    from: userAddress
                });
                
                console.log('USDC approved:', approveTx.transactionHash);
                
                // Wait a moment for the approval to be confirmed
                await new Promise(resolve => setTimeout(resolve, 2000));
                
            } catch (error) {
                console.error('USDC approval failed:', error);
                throw new Error('USDC approval failed: ' + error.message);
            }
        } else {
            console.log('Sufficient allowance already exists');
        }
        
        // Step 2: Complete purchase using the NET amount (before fees)
        Swal.fire({
            title: 'Step 2: Complete Purchase',
            text: 'Please confirm token purchase in your wallet',
            icon: 'info',
            showConfirmButton: false,
            allowOutsideClick: false
        });
        
        // Call completePurchase with the NET USDC amount (before fees)
        const purchaseTx = await tokenSaleContract.methods.completePurchase(baseUsdcAmount.toString()).send({
            from: userAddress
        });
        // Generate receipt data
        // Generate receipt data with proper error handling
let receiptData;
try {
    // Safely get all values with fallbacks
    const currentDate = new Date().toLocaleString();
    const txHash = purchaseTx.transactionHash || 'Unknown';
    
    // Safely get LME price
    let priceHuman = 'N/A';
    try {
        if (centralContract && centralContract.methods && centralContract.methods.LMEprice) {
            const lmePrice = await centralContract.methods.LMEprice().call();
            priceHuman = web3.utils.fromWei(lmePrice.toString(), 'mwei');
        }
    } catch (priceError) {
        console.warn('Could not fetch LME price:', priceError);
    }
    
    // Safely get network name
    let networkName = "Unknown Network";
    try {
        if (window.getNetworkName) {
            networkName = await window.getNetworkName().catch(() => "Unknown Network");
        }
    } catch (networkError) {
        console.warn('Could not get network name:', networkError);
    }
    
    receiptData = {
        date: currentDate,
        txHash: txHash,
        amount: tokenAmountHuman || '0',
        price: priceHuman,
        baseCost: baseUsdcHuman || '0',
        fees: feeAmountHuman || '0',
        totalCost: totalUsdcHuman || '0',
        network: networkName
    };
} catch (error) {
    console.warn('Error generating receipt data, using fallback:', error);
    // Minimal fallback data
    receiptData = {
        date: new Date().toLocaleString(),
        txHash: purchaseTx.transactionHash || 'Unknown',
        amount: tokenAmountHuman || '0',
        price: 'N/A',
        baseCost: baseUsdcHuman || '0',
        fees: feeAmountHuman || '0',
        totalCost: totalUsdcHuman || '0',
        network: 'Unknown Network'
    };
}
// Generate PNG receipt with error handling
let pngUrl;
try {
    pngUrl = await window.generatePNGReceipt(receiptData);
} catch (error) {
    console.error('Error generating PNG receipt:', error);
    // Fallback success message without receipt
    await Swal.fire({
        title: 'Purchase Successful!',
        html: `
            <div style="text-align: center;">
                <p><strong>${tokenAmountHuman} TKN</strong> purchased successfully!</p>
                <p>Transaction: <code>${purchaseTx.transactionHash ? purchaseTx.transactionHash.slice(0, 10) + '...' : 'Unknown'}</code></p>
                <div style="background: #f0f8ff; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong>Purchase Summary:</strong><br>
                    â€¢ Tokens Received: ${tokenAmountHuman}<br>
                    â€¢ Total USDC Paid: ${totalUsdcHuman} USDC<br>
                    â€¢ Transaction: ${purchaseTx.transactionHash ? purchaseTx.transactionHash.slice(0, 10) + '...' + purchaseTx.transactionHash.slice(-8) : 'Unknown'}
                </div>
            </div>
        `,
        icon: 'success',
        confirmButtonText: 'OK'
    });
    
    // Clean up and return
    const transferButton = document.getElementById('transferUSDCButton');
    if (transferButton) transferButton.remove();
    localStorage.removeItem('pendingPurchase');
    delete window.pendingTokenPurchase;
    return;
}
        
     // Success message with receipt download option
await Swal.fire({
    title: 'Purchase Successful!',
    html: `
        <div style="text-align: center;">
            ${pngUrl ? `<img src="${pngUrl}" style="max-width: 100%; border-radius: 8px; margin: 10px 0;">` : ''}
            <p><strong>${tokenAmountHuman || 'Unknown'} TKN</strong> purchased successfully!</p>
            <p>Transaction: <code>${purchaseTx.transactionHash ? purchaseTx.transactionHash.slice(0, 10) + '...' : 'Unknown'}</code></p>
        </div>
    `,
    icon: 'success',
    confirmButtonText: pngUrl ? 'Download Receipt' : 'OK',
    showCancelButton: !!pngUrl,
    cancelButtonText: 'Close'
}).then((result) => {
    if (result.isConfirmed && pngUrl) {
        const link = document.createElement('a');
        link.href = pngUrl;
        link.download = `purchase_${Date.now()}.png`;
        link.click();
    }
    // Clean up
    if (pngUrl) {
        URL.revokeObjectURL(pngUrl);
    }
});
        
        // Remove transfer button after successful purchase
        const transferButton = document.getElementById('transferUSDCButton');
        if (transferButton) transferButton.remove();
        
        // Clear pending purchase data
        localStorage.removeItem('pendingPurchase');
        delete window.pendingTokenPurchase;
        
    } catch (error) {
        console.error('Purchase failed:', error);
        Swal.fire({
            title: 'Purchase Failed',
            text: error.message,
            icon: 'error'
        });
    }
}
// Rest of your functions (addEnhancedBuyButtonToUI, initializeApp) remain the same...
function addEnhancedBuyButtonToUI() {
    // Remove existing widget first
    const existingWidget = document.getElementById('nclBuyWidget');
    if (existingWidget) existingWidget.remove();
    
    // Create the main widget container
    const widgetContainer = document.createElement('div');
    widgetContainer.id = 'nclBuyWidget';
    widgetContainer.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 20px;
        padding: 30px;
        margin: 20px auto;
        max-width: 400px;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
        text-align: center;
        font-family: 'Arial', sans-serif;
        position: relative;
        overflow: hidden;
    `;
    
    if (!window.appState || !window.appState.isConnected) {
        // Show disabled state when not connected
        widgetContainer.innerHTML = `
            <div style="position: absolute; top: -50px; right: -50px; width: 100px; height: 100px; background: rgba(255, 255, 255, 0.1); border-radius: 50%;"></div>
            <div style="position: absolute; bottom: -30px; left: -30px; width: 80px; height: 80px; background: rgba(255, 255, 255, 0.1); border-radius: 50%;"></div>
            
            <div style="position: relative; z-index: 2;">
                <h2 style="margin: 0 0 10px 0; font-size: 28px; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                    ðŸ’³ Buy NCL Tokens
                </h2>
                <p style="margin: 0 0 25px 0; opacity: 0.9; font-size: 16px;">
                    Purchase NCL tokens instantly with credit card
                </p>
                
                <div style="background: rgba(255, 255, 255, 0.15); padding: 20px; border-radius: 15px; margin: 20px 0; backdrop-filter: blur(10px);">
                    <p style="margin: 0 0 15px 0; font-size: 14px; opacity: 0.9;">
                        Easy â€¢ Fast â€¢ Secure
                    </p>
                    
                    <button id="nclConnectWalletButton" style="
                        background: linear-gradient(135deg, #f6851b, #e2761b);
                        color: white;
                        border: none;
                        padding: 18px 30px;
                        border-radius: 50px;
                        font-size: 18px;
                        font-weight: bold;
                        cursor: pointer;
                        width: 100%;
                        transition: all 0.3s ease;
                        box-shadow: 0 8px 25px rgba(246, 133, 27, 0.4);
                        text-transform: uppercase;
                        letter-spacing: 1px;
                        opacity: 0.9;
                    ">
                        ðŸ”— CONNECT WALLET TO BUY
                    </button>
                    
                    <p style="margin: 15px 0 0 0; font-size: 12px; opacity: 0.8;">
                        Connect your wallet to start purchasing tokens
                    </p>
                </div>
                
                <div style="display: flex; justify-content: space-around; margin-top: 20px; font-size: 12px; opacity: 0.8;">
                    <div>ðŸ”’ Secure</div>
                    <div>âš¡ Instant</div>
                    <div>ðŸ’Ž Easy</div>
                </div>
            </div>
        `;
        
        // Add hover effects to the connect button
        const connectButton = widgetContainer.querySelector('#nclConnectWalletButton');
        connectButton.addEventListener('mouseover', function() {
            this.style.transform = 'translateY(-3px)';
            this.style.boxShadow = '0 12px 30px rgba(246, 133, 27, 0.6)';
            this.style.opacity = '1';
        });
        
        connectButton.addEventListener('mouseout', function() {
            this.style.transform = 'translateY(0)';
            this.style.boxShadow = '0 8px 25px rgba(246, 133, 27, 0.4)';
            this.style.opacity = '0.9';
        });
        
        connectButton.addEventListener('click', function() {
            document.getElementById('connectButton')?.click();
        });
        
    } else {
        // Show active buy button when connected (your existing code)
        widgetContainer.innerHTML = `
            <div style="position: absolute; top: -50px; right: -50px; width: 100px; height: 100px; background: rgba(255, 255, 255, 0.1); border-radius: 50%;"></div>
            <div style="position: absolute; bottom: -30px; left: -30px; width: 80px; height: 80px; background: rgba(255, 255, 255, 0.1); border-radius: 50%;"></div>
            
            <div style="position: relative; z-index: 2;">
                <h2 style="margin: 0 0 10px 0; font-size: 28px; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                    ðŸ’³ Buy NCL Tokens
                </h2>
                <p style="margin: 0 0 25px 0; opacity: 0.9; font-size: 16px;">
                    Purchase NCL tokens instantly with credit card
                </p>
                
                <div style="background: rgba(255, 255, 255, 0.15); padding: 20px; border-radius: 15px; margin: 20px 0; backdrop-filter: blur(10px);">
                    <p style="margin: 0 0 15px 0; font-size: 14px; opacity: 0.9;">
                        Easy â€¢ Fast â€¢ Secure
                    </p>
                    
                    <button id="nclBuyNowButton" style="
                        background: linear-gradient(135deg, #f6851b, #e2761b);
                        color: white;
                        border: none;
                        padding: 18px 30px;
                        border-radius: 50px;
                        font-size: 18px;
                        font-weight: bold;
                        cursor: pointer;
                        width: 100%;
                        transition: all 0.3s ease;
                        box-shadow: 0 8px 25px rgba(246, 133, 27, 0.4);
                        text-transform: uppercase;
                        letter-spacing: 1px;
                    ">
                        ðŸš€ BUY NOW
                    </button>
                    
                    <p style="margin: 15px 0 0 0; font-size: 12px; opacity: 0.8;">
                        Ready to purchase tokens
                    </p>
                </div>
                
                <div style="display: flex; justify-content: space-around; margin-top: 20px; font-size: 12px; opacity: 0.8;">
                    <div>ðŸ”’ Secure</div>
                    <div>âš¡ Instant</div>
                    <div>ðŸ’Ž Easy</div>
                </div>
            </div>
        `;
        
        // Add hover effects to the buy button
        const buyButton = widgetContainer.querySelector('#nclBuyNowButton');
        buyButton.addEventListener('mouseover', function() {
            this.style.transform = 'translateY(-3px)';
            this.style.boxShadow = '0 12px 30px rgba(246, 133, 27, 0.6)';
        });
        
        buyButton.addEventListener('mouseout', function() {
            this.style.transform = 'translateY(0)';
            this.style.boxShadow = '0 8px 25px rgba(246, 133, 27, 0.4)';
        });
        
        buyButton.addEventListener('click', function() {
            Swal.fire({
                title: 'Buy NCL Tokens',
                html: `
                    <div style="text-align: center;">
                        <p style="font-size: 16px; margin-bottom: 20px;">Enter amount of NCL tokens to buy:</p>
                        <input type="number" id="tokenAmount" value="100" min="10" step="10" 
                               style="padding: 15px; margin: 10px 0; width: 100%; border: 2px solid #667eea; border-radius: 10px; font-size: 16px; text-align: center;">
                        <p style="font-size: 0.9em; color: #667; margin-top: 10px;">Minimum purchase: 10 tokens</p>
                    </div>
                `,
                showCancelButton: true,
                confirmButtonText: 'Continue to Purchase',
                cancelButtonText: 'Cancel',
                confirmButtonColor: '#667eea',
                width: '500px',
                customClass: {
                    popup: 'animated-popup'
                },
                preConfirm: () => {
    const amount = document.getElementById('tokenAmount').value;
    if (!amount || amount < 10) {
        Swal.showValidationMessage('Please enter at least 10 tokens');
        return false;
    }
    if (amount > 2000) {
        Swal.showValidationMessage('Maximum allowed is 2000 tokens');
        return false;
    }
    return amount;
}
            }).then((result) => {
                if (result.isConfirmed) {
                    window.openBuyWidget(result.value);
                }
            });
        });
    }
    
    // Add to page - you can customize the container where you want it to appear
    const targetContainer = document.getElementById('buyWidgetContainer') || 
                           document.querySelector('.main-content') || 
                           document.querySelector('body');
    
    if (targetContainer) {
        targetContainer.appendChild(widgetContainer);
        console.log('âœ… NCL Buy Widget added successfully');
    }
}
// SIMPLIFIED INITIALIZATION
function initializeApp() {
    console.log('ðŸš€ Initializing application with fee support...');
	
    initializeBuyWidget();
    // Wait for wallet connection
    window.addEventListener('appState:connectionChanged', function(e) {
        if (e.detail?.ready) {
            console.log('ðŸ’° Wallet connected, initializing buy widget');
            setTimeout(initializeBuyWidget, 1000);
        }
    });
    
    // If wallet is already connected
    if (window.appState && window.appState.isConnected) {
        console.log('âš¡ Wallet already connected');
        setTimeout(initializeBuyWidget, 2000);
    }
}
// Start the application
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp();
}
console.log('ðŸŽ¯ Enhanced buy widget with fee support loaded'); </script>
        </div>
      </div>
    </section>
    
    
    
    
    
    
    
    
    
    
    
    <footer class="u-align-center u-black u-clearfix u-container-align-center u-footer" id="sec-8726"><div class="u-clearfix u-sheet u-sheet-1">
        <p class="u-align-center u-small-text u-text u-text-variant u-text-1"> Â© All Rights Reserved, Decentralized Application , 2025 , Destrier LLC, 1942 Broadway St. , STE 314C, Boulder, CO 80302, US<br>
          <a href="#" class="u-active-none u-border-none u-btn u-button-link u-button-style u-hover-none u-none u-text-body-alt-color u-btn-1">www.nickelium.com</a>
        </p>
      </div></footer><section class="u-align-center u-clearfix u-cookies-consent u-grey-80 u-cookies-consent" id="sec-b719">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="u-clearfix u-expanded-width u-layout-wrap u-layout-wrap-1">
          <div class="u-gutter-0 u-layout">
            <div class="u-layout-row">
              <div class="u-container-style u-layout-cell u-left-cell u-size-43-md u-size-43-sm u-size-43-xs u-size-46-lg u-size-46-xl u-layout-cell-1">
                <div class="u-container-layout u-valign-middle u-container-layout-1">
                  <h3 class="u-text u-text-default u-text-1">Cookies &amp; Privacy</h3>
                  <p class="u-text u-text-default u-text-2">This website uses cookies to ensure you get the best experience on our website.</p>
                </div>
              </div>
              <div class="u-align-left u-container-style u-layout-cell u-right-cell u-size-14-lg u-size-14-xl u-size-17-md u-size-17-sm u-size-17-xs u-layout-cell-2">
                <div class="u-container-layout u-valign-middle-lg u-valign-middle-md u-valign-middle-xl u-valign-top-sm u-valign-top-xs u-container-layout-2">
                  <a href="###" class="u-btn u-button-confirm u-button-style u-palette-1-base u-btn-1">Confirm</a>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    <style> .u-cookies-consent {
  background-image: none;
}

.u-cookies-consent .u-sheet-1 {
  min-height: 212px;
}

.u-cookies-consent .u-layout-wrap-1 {
  margin-top: 30px;
  margin-bottom: 30px;
}

.u-cookies-consent .u-layout-cell-1 {
  min-height: 152px;
}

.u-cookies-consent .u-container-layout-1 {
  padding: 30px 60px;
}

.u-cookies-consent .u-text-1 {
  margin-top: 0;
  margin-right: 20px;
  margin-bottom: 0;
}

.u-cookies-consent .u-text-2 {
  margin: 8px 20px 0 0;
}

.u-cookies-consent .u-layout-cell-2 {
  min-height: 152px;
}

.u-cookies-consent .u-container-layout-2 {
  padding: 30px;
}

.u-cookies-consent .u-btn-1 {
  margin: 0 auto 0 0;
}

@media (max-width: 1199px) {
  .u-cookies-consent .u-sheet-1 {
    min-height: 131px;
  }

  .u-cookies-consent .u-layout-cell-1 {
    min-height: 125px;
  }

  .u-cookies-consent .u-text-1 {
    margin-right: 0;
  }

  .u-cookies-consent .u-text-2 {
    margin-right: 0;
  }

  .u-cookies-consent .u-layout-cell-2 {
    min-height: 125px;
  }
}

@media (max-width: 991px) {
  .u-cookies-consent .u-sheet-1 {
    min-height: 106px;
  }

  .u-cookies-consent .u-layout-cell-1 {
    min-height: 100px;
  }

  .u-cookies-consent .u-container-layout-1 {
    padding-left: 30px;
    padding-right: 30px;
  }

  .u-cookies-consent .u-layout-cell-2 {
    min-height: 100px;
  }
}

@media (max-width: 767px) {
  .u-cookies-consent .u-sheet-1 {
    min-height: 225px;
  }

  .u-cookies-consent .u-layout-cell-1 {
    min-height: 154px;
  }

  .u-cookies-consent .u-container-layout-1 {
    padding-left: 10px;
    padding-right: 10px;
    padding-bottom: 20px;
  }

  .u-cookies-consent .u-layout-cell-2 {
    min-height: 65px;
  }

  .u-cookies-consent .u-container-layout-2 {
    padding: 10px;
  }
}

@media (max-width: 575px) {
  .u-cookies-consent .u-sheet-1 {
    min-height: 121px;
  }

  .u-cookies-consent .u-layout-cell-1 {
    min-height: 100px;
  }

  .u-cookies-consent .u-layout-cell-2 {
    min-height: 15px;
  }
}</style></section>
  
</body></html>